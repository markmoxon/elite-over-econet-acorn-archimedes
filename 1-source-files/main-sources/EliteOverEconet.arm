\ ******************************************************************************
\
\ ELITE OVER ECONET MODULE SOURCE
\
\ The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
\ in the documentation are entirely my fault
\
\ The terminology and notations used in this commentary are explained at
\ https://elite.bbcelite.com/terminology
\
\ The deep dive articles referred to in this commentary can be found at
\ https://elite.bbcelite.com/deep_dives
\
\ ------------------------------------------------------------------------------
\
\ This source file produces the following binary file:
\
\   * EliteNet.bin
\
\ ******************************************************************************

 CODE = &00000000                   \ The build address for the Module

\ ******************************************************************************
\
\ Operating system SWI numbers
\
\ ******************************************************************************

 XOS_WriteC = &20000                \ The operating system call for printing a
                                    \ character

 XOS_Write0 = &20002                \ The operating system call for printing a
                                    \ null-terminated string

 XOS_Newline = &20003               \ The operating system call for printing a
                                    \ newline

 XOS_Module = &2001E                \ The operating system call for claiming
                                    \ workspace for a module

 XOS_EvaluateExpression = &2002D    \ The operating system call to convert a
                                    \ string into a number

 XOS_ValidateAddress = &2003A       \ The operating system call to check whether
                                    \ an address range is in logical RAM

 XOS_CallEvery = &2003C             \ The operating system call to call a
                                    \ routine regularly

 XOS_RemoveTickerEvent = &2003D     \ The operating system call to remove a call
                                    \ set up by OS_CallEvery

 XOS_ConvertCardinal1 = &200D5      \ The operating system call for printing an
                                    \ unsigned integer byte

 XOS_ConvertCardinal4 = &200D8      \ The operating system call for printing an
                                    \ unsigned integer word

 XOS_WriteI = &20100                \ The operating system call for printing the
                                    \ character specified in the SWI number

 XEconet_StartTransmit = &60006     \ The operating system call to create a
                                    \ Transmit Control Block and start a
                                    \ transmission over Econet

 XEconet_AbandonTransmit = &60008   \ The operating system call to abandon a
                                    \ Transmit Control Block and reclaim the
                                    \ memory

 XEconet_ReadStationNumber = &6000F \ The operating system call to convert a
                                    \ string into a network and station number

 XMessageTrans_ErrorLookup = &60516 \ The operating system call to expand tokens
                                    \ in an error string

 XElite_GameOver = &E0CC0           \ The SWI call to inject when the game
                                    \ prints the GAME OVER string

 XElite_GameRestart = &E0CC1        \ The SWI call to inject when the game
                                    \ prints the copyright message on the title
                                    \ screen

\ ******************************************************************************
\
\ Econet variables
\
\ ******************************************************************************

 startWorkspace = &00               \ The start of the workspace

                                    \ R12 typically contains the address of the
                                    \ module's private workspace, so each of the
                                    \ variables in the workspace can be referred
                                    \ to as:
                                    \
                                    \   [R12, #offset]
                                    \
                                    \ where #offset is one of the following
                                    \ variables

 scorePort = &00                    \ The Econet port on which to talk to the
                                    \ scoreboard machine
                                    \
                                    \ If this is zero, the network is disabled
                                    \ and no commander data is transmitted

 scoreStation = &04                 \ The station number of the scoreboard
                                    \ machine

 scoreNetwork = &08                 \ The network number of the scoreboard
                                    \ machine

 currentRank = &0C                  \ The current commander rank, so we can
                                    \ track it

 netTally = &10                     \ Stores a one-point-per-kill combat score
                                    \ for the scoreboard (so all platforms have
                                    \ the same point system)

 netDeaths = &14                    \ Counts the number of deaths

 econetHandle = &18                 \ The handle of the last packet transmission

 semaphore = &1C                    \ A flag to stop us from starting a new
                                    \ transmission before we have finished the
                                    \ current one

 transmitBuffer = &20               \ The tramsmit buffer

 trName = &20                       \ Bytes #0-7 = commander's name, terminated
                                    \ by a carriage return

 trLegal = &28                      \ Byte #8 = commander's legal status:
                                    \
                                    \   * 0 = Clean
                                    \   * 1 = Offender
                                    \   * 2 = Fugitive

 trCondition = &29                  \ Byte #9 = commander's status condition:
                                    \
                                    \   * 0 = Docked
                                    \   * 1 = Green
                                    \   * 2 = Yellow
                                    \   * 3 = Red

 trKill = &2A                       \ Byte #10 = commander's kill count

 trDeaths = &2B                     \ Byte #11 = commander's death count

 trCredits = &2C                    \ Bytes #12-15 = commander's credits

 trMachine = &30                    \ Byte #16 = machine type:
                                    \
                                    \   * 0 = BBC Micro SRAM
                                    \   * 1 = Master
                                    \   * 2 = 6502SP
                                    \   * 3 = BBC Micro standard
                                    \   * 4 = Archimedes

 scoreEnabled = &34                 \ Flag to control whether we transmit scores
                                    \ to the scoreboard
                                    \
                                    \   * Zero = do not transmit scores
                                    \   * Non-zero = do transmit scores

 scoreInterval = &38                \ The interval between score transmissions
                                    \ in centiseconds

 stringBuffer = &3C                 \ String buffer for processing command line
                                    \ parameters (12 characters)

 gameIsOver = &48                   \ A flag to determine whether the game is in
                                    \ the process of ending

 patchApplied = &4C                 \ A flag to determine whether the game over
                                    \ patch has been applied

 endWorkspace = &50                 \ End of the private workspace

 workspaceSize = endWorkspace - startWorkspace  \ The size of the workspace

\ ******************************************************************************
\
\ ELITE OVER ECONET MODULE CODE
\
\ Produces the binary file EliteNet.bin.
\
\ ******************************************************************************

 DIM CODE% &1000                    \ Reserve a block in memory for the
                                    \ assembled code

 FOR pass% = 4 TO 6 STEP 2          \ Perform a two-pass assembly, using both
                                    \ P% and O%, with errors enabled on the
                                    \ second pass only

 O% = CODE%                         \ Assemble the code for deployment to
                                    \ address O%

 P% = CODE                          \ Assemble the code into the block at P%

[                                   \ Switch from BASIC into assembly language

 OPT    pass%                       \ Set the assembly option for this pass

\ ******************************************************************************
\
\       Name: Module header
\       Type: Subroutine
\   Category: Econet
\    Summary: Relocatable module header
\
\ ******************************************************************************

 EQUD    0                          \ Offset to start code

 EQUD    InitialiseModule           \ Offset to initialisation code

 EQUD    FinaliseModule             \ Offset to finalisation code

 EQUD    0                          \ Offset to service call handler

 EQUD    title                      \ Offset to title string

 EQUD    help                       \ Offset to help string

 EQUD    helpAndCommandTable        \ Offset to help and command keyword table

 EQUD    &C0CC0                     \ SWI chunk base number

 EQUD    SWIHandler                 \ Offset to SWI handler code

 EQUD    swiDecodingTable           \ Offset to SWI decoding table

 EQUD    0                          \ Offset to SWI decoding code

\ ******************************************************************************
\
\       Name: Module title
\       Type: Variable
\   Category: Econet
\    Summary: Relocatable module title string
\
\ ******************************************************************************

.title

 EQUS    "EliteOverEconet"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: Module help text
\       Type: Variable
\   Category: Econet
\    Summary: Relocatable module help string
\
\ ******************************************************************************

.help

 EQUS    "EliteOverEconet"
 EQUB    9
 EQUS    "0.10 (04 Apr 2025)"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: Module help and command table
\       Type: Variable
\   Category: Econet
\    Summary: Relocatable module help and command table
\
\ ******************************************************************************

.helpAndCommandTable

                                    \ *EliteStatus

 EQUS    "EliteStatus"              \ String to match, null terminated
 EQUB    0
 ALIGN

 EQUD    EliteStatus                \ Offset of code from module start

 EQUB    0                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    0                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteStatusHelp            \ Offset of help text

                                    \ *EliteTxStation <network>.<station>

 EQUS    "EliteTxStation"           \ String to match, null terminated
 EQUB    0
 ALIGN

 EQUD    EliteTxStation             \ Offset of code from module start

 EQUB    1                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    1                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxStationHelp         \ Offset of help text

                                    \ *EliteTxPort <port>

 EQUS    "EliteTxPort"              \ String to match, null terminated
 EQUB    0
 ALIGN

 EQUD    EliteTxPort                \ Offset of code from module start

 EQUB    1                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    1                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxPortHelp            \ Offset of help text

                                    \ *EliteTxInterval <interval>

 EQUS    "EliteTxInterval"          \ String to match, null terminated
 EQUB    0
 ALIGN

 EQUD    EliteTxInterval            \ Offset of code from module start

 EQUB    1                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    1                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxIntervalHelp        \ Offset of help text

                                    \ *EliteTxStart

 EQUS    "EliteTxStart"             \ String to match, null terminated
 EQUB    0
 ALIGN

 EQUD    EliteTxStart               \ Offset of code from module start

 EQUB    0                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    0                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxStartHelp           \ Offset of help text

                                    \ *EliteTxStop

 EQUS    "EliteTxStop"              \ String to match, null terminated
 EQUB    0
 ALIGN

 EQUD    EliteTxStop                \ Offset of code from module start

 EQUB    0                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    0                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxStopHelp            \ Offset of help text

                                    \ *EliteTxReset

 EQUS    "EliteTxReset"             \ String to match, null terminated
 EQUB    0
 ALIGN

 EQUD    EliteTxReset               \ Offset of code from module start

 EQUB    0                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    0                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxResetHelp           \ Offset of help text

 EQUD    0                          \ End of command table

\ ******************************************************************************
\
\       Name: EliteTxPort
\       Type: Subroutine
\   Category: Econet
\    Summary: Implement the EliteTxPort command
\
\ ******************************************************************************

.EliteTxPort

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 ADD     R1, R12, #stringBuffer     \ Try converting the parameter to an integer
 MOV     R2, #12                    \ using the string buffer in the workspace
 SWI     XOS_EvaluateExpression

 BVS     port1                      \ Report an error if the conversion went
                                    \ wrong

 TEQ     R1, #0                     \ Report an error if the result is not an
 BNE     port1                      \ integer

 CMP     R2, #1                     \ Report an error if the port number is not
 BLT     port1                      \ in the range 1 to 254
 CMP     R2, #254
 BGT     port1

 STR     R2, [R12, #scorePort]      \ Set scorePort to the new port number

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

 LDMFD   R13!, {PC}                 \ Return from the subroutine

.port1

 ADR     R0, eliteTxPortError       \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set (in bit 28 of the program counter)

.eliteTxPortError

 EQUD    0
 EQUS    "Invalid port number (it must be in the range 1 to 254)"
 EQUB    0
 ALIGN

.eliteTxPortHelp

 EQUS    "*EliteTxPort sets the port number for transmitting scores."
 EQUB    13
 EQUS    "Syntax: *EliteTxPort <port>"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: EliteTxStation
\       Type: Subroutine
\   Category: Econet
\    Summary: Implement the EliteTxStation command
\
\ ******************************************************************************

.EliteTxStation

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 MOV     R1, R0                     \ Try converting the parameter to a station
 SWI     XEconet_ReadStationNumber  \ and network number
 
 BVS     stat1                      \ Report the SWI error if the conversion
                                    \ went wrong, as this could mean that Econet
                                    \ is disabled

 CMN     R2, #1                     \ Report an error if the result does not
 BEQ     stat2                      \ contain a valid station number

 CMN     R3, #1                     \ Set R3 = 0 if the result does not contain
 MOVEQ   R3, #0                     \ a valid network number

 STR     R2, [R12, #scoreStation]   \ Set scoreNetwork to the new station number

 STR     R3, [R12, #scoreNetwork]   \ Set scoreNetwork to the new network number

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

.stat1

 LDMFD   R13!, {PC}                 \ Return from the subroutine

.stat2

 ADR     R0, eliteTxStationError    \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set (in bit 28 of the program counter)

.eliteTxStationError

 EQUD    0
 EQUS    "Invalid station (it must be in the format 123 or 1.234)"
 EQUB    0
 ALIGN

.eliteTxStationHelp

 EQUS    "*EliteTxStation sets the network and station number "
 EQUS    "for transmitting scores."
 EQUB    13
 EQUS    "Syntax: *EliteTxStation [<network>.]<station>"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: EliteTxInterval
\       Type: Subroutine
\   Category: Econet
\    Summary: Implement the EliteTxInterval command
\
\ ******************************************************************************

.EliteTxInterval

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 ADD     R1, R12, #stringBuffer     \ Try converting the parameter to an integer
 MOV     R2, #12                    \ using the string buffer in the workspace
 SWI     XOS_EvaluateExpression

 BVS     intv2                      \ Report an error if the conversion went
                                    \ wrong

 TEQ     R1, #0                     \ Report an error if the result is not an
 BNE     intv2                      \ integer

 CMP     R2, #100                   \ Report an error if the interval is < 100
 BLT     intv2

 STR     R2, [R12, #scoreInterval]  \ Set scoreInterval to the new port number

 LDR     R1, [R12, #scoreEnabled]   \ Set R1 to the current enabled state

 TEQ     R1, #0                     \ If transmissions are stopped, jump to
 BEQ     intv1                      \ intv1 to skip the ticker event reset

 ADR     R0, TransmitData           \ Remove the TransmitData routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called (we set R1 to the address of the
                                    \ module's private workspace so it matches
                                    \ the value of R2 that was used when adding
                                    \ the routine to the ticker list)

 LDR     R0, [R12, #scoreInterval]  \ Add a call to the TransmitData routine
 ADR     R1, TransmitData           \ into the ticker event list so it gets
 MOV     R2, R12                    \ called every scoreInterval centiseconds,
 SWI     XOS_CallEvery              \ to transmit the commander data to the
                                    \ scoreboard

.intv1

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

 LDMFD   R13!, {PC}                 \ Return from the subroutine

.intv2

 ADR     R0, eliteTxIntervalError   \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set (in bit 28 of the program counter)

.eliteTxIntervalError

 EQUD    0
 EQUS    "Invalid interval (it must be at least 100)"
 EQUB    0
 ALIGN

.eliteTxIntervalHelp

 EQUS    "*EliteTxInterval sets the interval in centiseconds "
 EQUS    "between score transmissions."
 EQUB    13
 EQUS    "Syntax: *EliteTxInterval <interval>"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: EliteTxStop
\       Type: Subroutine
\   Category: Econet
\    Summary: Implement the EliteTxStop command
\
\ ******************************************************************************

.EliteTxStop

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 LDR     R1, [R12, #scoreEnabled]   \ Set R1 to the current enabled state

 TEQ     R1, #0                     \ If transmissions are already stopped, jump
 BEQ     stop1                      \ to stop1 to report this

 MOV     R0, #0                     \ Set scoreEnabled = 0 to denote that score
 STR     R0, [R12, #scoreEnabled]   \ transmissions are disabled

 ADR     R0, TransmitData           \ Remove the TransmitData routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called (we set R1 to the address of the
                                    \ module's private workspace so it matches
                                    \ the value of R2 that was used when adding
                                    \ the routine to the ticker list)

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

 LDMFD   R13!, {PC}                 \ Return from the subroutine

.stop1

 ADR     R0, eliteTxStopError       \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set (in bit 28 of the program counter)

.eliteTxStopError

 EQUD    0
 EQUS    "Transmissions are already disabled"
 EQUB    0
 ALIGN

.eliteTxStopHelp

 EQUS    "*EliteTxStop disables score transmissions."
 EQUB    13
 EQUS    "Syntax: *EliteTxStop"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: EliteTxStart
\       Type: Subroutine
\   Category: Econet
\    Summary: Implement the EliteTxStart command
\
\ ******************************************************************************

.EliteTxStart

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 LDR     R1, [R12, #scoreEnabled]   \ Set R1 to the current enabled state

 TEQ     R1, #1                     \ If transmissions are already started, jump
 BEQ     star1                      \ to star1 to report this

 LDR     R1, [R12, #scorePort]      \ Set R1 to the port number and R2 to the
 TEQ     R1, #0                     \ station number, setting the Z flag if
 LDRNE   R2, [R12, #scoreStation]   \ either of them is zero
 TEQNE   R2, #0

 BEQ     star2                      \ If either of them is zero, jump to star2
                                    \ to report this and prevent startup

 MOV     R0, #1                     \ Set scoreEnabled = 1 to denote that score
 STR     R0, [R12, #scoreEnabled]   \ transmissions are enabled

 LDR     R0, [R12, #scoreInterval]  \ Add a call to the TransmitData routine
 ADR     R1, TransmitData           \ into the ticker event list so it gets
 MOV     R2, R12                    \ called every scoreInterval centiseconds,
 SWI     XOS_CallEvery              \ to transmit the commander data to the
                                    \ scoreboard

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

 LDMFD   R13!, {PC}                 \ Return from the subroutine

.star1

 ADR     R0, eliteTxStartError1     \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set (in bit 28 of the program counter)

.star2

 ADR     R0, eliteTxStartError2     \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set (in bit 28 of the program counter)

.eliteTxStartError1

 EQUD    0
 EQUS    "Transmissions are already enabled"
 EQUB    0
 ALIGN

.eliteTxStartError2

 EQUD    0
 EQUS    "Both the port and station number must be "
 EQUS    "non-zero to enable transmissions"
 EQUB    0
 ALIGN

.eliteTxStartHelp

 EQUS    "*EliteTxStart enables score transmissions."
 EQUB    13
 EQUS    "Syntax: *EliteTxStart"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: EliteTxReset
\       Type: Subroutine
\   Category: Econet
\    Summary: Implement the EliteTxReset command
\
\ ******************************************************************************

.EliteTxReset

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 MOV     R0, #0                     \ Zero the kill tally and death count
 STR     R0, [R12, #netTally]
 STR     R0, [R12, #netDeaths]

 LDMFD   R13!, {PC}                 \ Return from the subroutine

.eliteTxResetHelp

 EQUS    "*EliteTxReset resets the kill tally and death count."
 EQUB    13
 EQUS    "Syntax: *EliteTxReset"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: EliteStatus
\       Type: Subroutine
\   Category: Econet
\    Summary: Implement the EliteStatus command
\
\ ******************************************************************************

.EliteStatus

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusIntro            \ Print the intro paragraph
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 SWI     XOS_Newline                \ Print a newline

 LDR     R0, [R12, #scoreEnabled]   \ Print the disabled or enabled message
 TEQ     R0, #0                     \ depending on the value of scoreEnabled
 ADREQ   R0, statusDisabled
 ADRNE   R0, statusEnabled
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusInterval1        \ Print "Transmit interval:  "
 SWI     XOS_Write0

 LDR     R0, [R12, #scoreInterval]  \ Print the score interval as a positive
 ADD     R1, R12, #stringBuffer     \ integer (32-bit)
 MOV     R2, #12
 SWI     XOS_ConvertCardinal4
 SWI     XOS_Write0

 ADR     R0, statusInterval2        \ Print " centiseconds"
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusStation          \ Print "Scoreboard station: "
 SWI     XOS_Write0

 LDR     R0, [R12, #scoreNetwork]   \ Print the network number as a positive
 ADD     R1, R12, #stringBuffer     \ integer (8-bit)
 MOV     R2, #12
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 MOV     R0, #&2E                   \ Print a full stop
 SWI     XOS_WriteC

 LDR     R0, [R12, #scoreStation]   \ Set R0 to the station number

 CMP     R0, #100                   \ Pad out the station number with leading
 SWILT   XOS_WriteI+&30             \ zeroes so it's three digits
 CMP     R0, #10
 SWILT   XOS_WriteI+&30

 ADD     R1, R12, #stringBuffer     \ Print the station number as a positive
 MOV     R2, #12                    \ integer (8-bit)
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusPort             \ Print "Scoreboard port:    "
 SWI     XOS_Write0

 LDR     R0, [R12, #scorePort]      \ Print the port number as a positive
 ADD     R1, R12, #stringBuffer     \ integer (8-bit)
 MOV     R2, #12
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusKills            \ Print "Kills/deaths:       "
 SWI     XOS_Write0

 LDR     R0, [R12, #netTally]       \ Print the kill tally as a positive
 ADD     R1, R12, #stringBuffer     \ integer (8-bit)
 MOV     R2, #12
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 MOV     R0, #&2F                   \ Print a /
 SWI     XOS_WriteC

 LDR     R0, [R12, #netDeaths]      \ Print the death count as a positive
 ADD     R1, R12, #stringBuffer     \ integer (8-bit)
 MOV     R2, #12
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 SWI     XOS_Newline                \ Print a newline

 LDMFD   R13!, {PC}                 \ Return from the subroutine

.statusIntro

 EQUS    "Current status of Elite over Econet:"
 EQUB    0
 ALIGN

.statusEnabled

 EQUS    "Transmissions:      Enabled"
 EQUB    0
 ALIGN

.statusDisabled

 EQUS    "Transmissions:      Disabled"
 EQUB    0
 ALIGN

.statusInterval1

 EQUS    "Transmit interval:  "
 EQUB    0
 ALIGN

.statusInterval2

 EQUS    " centiseconds"
 EQUB    0
 ALIGN

.statusStation

 EQUS    "Scoreboard station: "
 EQUB    0
 ALIGN

.statusPort

 EQUS    "Scoreboard port:    "
 EQUB    0
 ALIGN

.statusKills

 EQUS    "Kills/deaths:       "
 EQUB    0
 ALIGN

.eliteStatusHelp

 EQUS    "*EliteStatus shows the current status of Elite over Econet."
 EQUB    13
 EQUS    "Syntax: *EliteStatus"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: SWIHandler
\       Type: Subroutine
\   Category: Econet
\    Summary: Handle SWI calls to the module
\
\ ******************************************************************************

.SWIHandler

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 CMP     R11, #2 * 4                \ Jump to the correct SWI, if R11 is in
 ADDLO   PC, PC, R11, LSL #2        \ the correct range (i.e. the number of
                                    \ SWIs in the jump table * 4)

 B       UnknownSWIError            \ R11 is out of range, so return an error

.jump

 B       SWI_Elite_GameOver         \ Jump to SWI 0 within this chunk

 B       SWI_Elite_GameRestart      \ Jump to SWI 1 within this chunk

.UnknownSWIError

 ADR     R0, swiError               \ Transform the error message token in
 MOV     R1, #0                     \ swiError
 MOV     R2, #0
 ADR     R4, title
 SWI     XMessageTrans_ErrorLookup

 ORRS    PC, R14, #1<<28            \ Return from the subroutine with the V flag
                                    \ set (in bit 28 of the program counter)

.swiError

 EQUD    &1E6
 EQUS    "BadSWI"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: swiDecodingTable
\       Type: Subroutine
\   Category: Econet
\    Summary: Decoding table for the Elite_GameOver and Elite_GameRestart SWIs
\
\ ******************************************************************************

.swiDecodingTable

 EQUS    "Elite"                    \ Group prefix
 EQUB    0

 EQUS    "GameOver"                 \ SWI Elite_GameOver (&C0CC0)
 EQUB    0

 EQUS    "GameRestart"              \ SWI Elite_GameRestart (&C0CC1)
 EQUB    0

 EQUB    0                          \ End of table
 ALIGN

\ ******************************************************************************
\
\       Name: SWI_Elite_GameOver
\       Type: Subroutine
\   Category: Econet
\    Summary: Code for the Elite_GameOver SWI
\
\ ******************************************************************************

.SWI_Elite_GameOver

 MOV     R0, #1                     \ Set the gameIsOver flag to 1 to denote
 STR     R0, [R12, #gameIsOver]     \ that the game is in the process of ending

 MOV     R0, #&29                   \ Run the original code that we replaced

 MOVS    PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SWI_Elite_GameRestart
\       Type: Subroutine
\   Category: Econet
\    Summary: Code for the Elite_GameRestart SWI
\
\ ******************************************************************************

.SWI_Elite_GameRestart

 LDR     R2, [R12, #gameIsOver]     \ If gameIsOver is zero then the game is not
 TEQ     R2, #0                     \ in the process of ending, which means we
 BEQ     notDeath                   \ are not printing the copyright message on
                                    \ the title screen following a death, so
                                    \ jump to notDeath to return from the
                                    \ subroutine

 LDR     R2, [R12, #netDeaths]      \ Otherwise this is the title screen
 ADD     R2, R2, #1                 \ following a death, so increment the death
 STR     R2, [R12, #netDeaths]      \ count

 MOV     R2, #0                     \ Zero the gameIsOver flag to denote that
 STR     R2, [R12, #gameIsOver]     \ the game is no longer in the process of
                                    \ ending

.notDeath

 MOV     R2, #&12C                  \ Run the original code that we replaced

 MOVS    PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: InitialiseModule
\       Type: Subroutine
\   Category: Econet
\    Summary: Initialise the module
\
\ ******************************************************************************

.InitialiseModule

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R2, [R12]                  \ Set R2 to the module's private word

 TEQ     R2, #0                     \ If the private word is non-zero then we
 BNE     init1                      \ have already set up the module's private
                                    \ workspace and the private word contains
                                    \ the address of that workspace, so jump to
                                    \ init1 to skip the following, with the
                                    \ address of the workspace in R2

                                    \ If we get here then the module's workspace
                                    \ has not been set up, so we do that now

 MOV     R0, #6                     \ Claim the correct number of bytes for the
 MOV     R3, #workspaceSize         \ workspace, returning the address of the
 SWI     XOS_Module                 \ workspace in R2

 LDMVSFD R13!, {PC}                 \ If the C flag is set then the claim has
                                    \ failed and the module can't be run, so
                                    \ return without initialising the module

 STR     R2, [R12]                  \ Otherwise the claim was successful, so set
                                    \ the module's private word to the address
                                    \ of the claimed memory

 MOV     R1, #0                     \ Reset the handle of the previous packet as
 STR     R1, [R2, #econetHandle]    \ there isn't one

 STR     R1, [R2, #netTally]        \ Zero the kill tally

 STR     R1, [R2, #netDeaths]       \ Zero the death count

 STR     R1, [R2, #gameIsOver]      \ Zero the gameIsOver flag to denote that
                                    \ the game is not in the process of ending

 STR     R1, [R2, #patchApplied]    \ Zero the patchApplied flag to denote that
                                    \ the game over patch has not yet been
                                    \ applied

 STR     R1, [R2, #scoreNetwork]    \ Zero the scoreboard network details
 STR     R1, [R2, #scoreStation]
 STR     R1, [R2, #scorePort]

 STR     R1, [R2, #scoreEnabled]    \ Disable transmissions by default

 MVN     R1, #0                     \ Set the current rank to -1, to indicate
 STR     R1, [R2, #currentRank]     \ that we haven't yet fetched it from the
                                    \ game

 MOV     R1, #1000                  \ Initialise the transmission interval to
 STR     R1, [R2, #scoreInterval]   \ 1000 centiseconds (i.e. 10 seconds)

.init1

 MOV     R0, #50                    \ Add a call to the MonitorRank routine
 ADR     R1, MonitorRank            \ into the ticker event list so it gets
 SWI     XOS_CallEvery              \ called twice each second (i.e. every 50
                                    \ centiseconds), to check the commander's
                                    \ rank for changes
                                    \
                                    \ Note that R2 contains the address of the
                                    \ module's private workspace, so this will
                                    \ be sent to the routine in R12 whenever it
                                    \ is called

 LDMFD   R13!, {PC}^                \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FinaliseModule
\       Type: Subroutine
\   Category: Econet
\    Summary: Finalise the module
\
\ ******************************************************************************

.FinaliseModule

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 ADR     R0, TransmitData           \ Remove the TransmitData routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called (we set R1 to the address of the
                                    \ module's private workspace so it matches
                                    \ the value of R2 that was used when adding
                                    \ the routine to the ticker list)

 ADR     R0, MonitorRank            \ Remove the MonitorRank routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called

 LDR     R0, [R12, #econetHandle]   \ Fetch the handle of the previous packet

 TEQ     R0, #0                     \ If there is a handle, abandon the previous
 SWINE   XEconet_AbandonTransmit    \ transmission to recover its memory from
                                    \ the RMA

 MOV     R1, #0                     \ Reset the handle of the previous packet
 STR     R1, [R12, #econetHandle]

 LDMFD   R13!, {PC}^                \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TransmitData
\       Type: Subroutine
\   Category: Econet
\    Summary: Create and send an Econet data packet
\
\ ******************************************************************************

.TransmitData

 STMFD   R13!, {R0-R12}             \ Store the registers that we want to use on
                                    \ the stack so they can be preserved

                                    \ As we are calling this routine via the
                                    \ ticker event list the system will call the
                                    \ routine in SVC mode with interrupts
                                    \ disabled, so for us to be able to call
                                    \ SWIs, we need to save R14_svc on the stack
                                    \ to prevent corruption of the return
                                    \ address
                                    \
                                    \ Just to be on the safe side, we won't
                                    \ assume the processor mode that we are in,
                                    \ we'll just save that too so we can revert
                                    \ when we're done

 MOV     R5, PC                     \ Extract the current processor mode into R5
 BIC     R4, R5, #3                 \ from bits 0 and 1 of the program counter

 TEQP    R4, #3                     \ Switch to SVC mode
 MOV     R0, R0

 STMFD   R13!, {R5, R14}            \ Store the original processor mode (in R5)
                                    \ and R14_svc on the stack, so we can revert
                                    \ both of them when we are done

 LDR     R0, string1Addr            \ Check to see if the first string to match
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R0, [R0]                   \ If the first string doesn't match, jump
 LDR     R1, string1Match           \ to skipT to return from the subroutine as
 CMP     R0, R1                     \ Elite is not paged in
 BNE     skipT

 LDR     R0, string2Addr            \ Check to see if the second string to match
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R0, [R0]                   \ If the second string doesn't match, jump
 LDR     R1, string2Match           \ to skipT to return from the subroutine as
 CMP     R0, R1                     \ Elite is not paged in
 BNE     skipT

 LDR     R0, string3Addr            \ Check to see if the third string to match
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R0, [R0]                   \ If the third string doesn't match, jump
 LDR     R1, string3Match           \ to skipT to return from the subroutine as
 CMP     R0, R1                     \ Elite is not paged in
 BNE     skipT

                                    \ If we get here then Elite is paged in

 LDR     R0, [R12, #semaphore]      \ If the semaphore flag is non-zero then we
 TEQ     R0, #0                     \ are already running this routine from a
 BNE     doneT                      \ previous ticker event, so jump to doneT
                                    \ to return from the subroutine without
                                    \ resetting the semaphore

 MOV     R0, #1                     \ Set the semaphore flag to a non-zero value
 STR     R0, [R12, #semaphore]      \ to indicate that there is a transmission
                                    \ in progress

 LDR     R0, [R12, #econetHandle]   \ Fetch the handle of the previous packet

 TEQ     R0, #0                     \ If there is a handle, abandon the previous
 SWINE   XEconet_AbandonTransmit    \ transmission to recover its memory from
                                    \ the RMA

 LDR     R0, cmdrName               \ Check to see if the commander name is in
 ADD     R1, R0, #4                 \ logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R2, [R0]                   \ Fetch the first word of the commander
 TST     R2, #&000000FF             \ name, convert any null bytes to carriage
 ORREQ   R2, R2, #&0000000D         \ returns and store the result in trName
 TST     R2, #&0000FF00
 ORREQ   R2, R2, #&00000D00
 TST     R2, #&00FF0000
 ORREQ   R2, R2, #&000D0000
 TST     R2, #&FF000000
 ORREQ   R2, R2, #&0D000000
 STR     R2, [R12, #trName]

 LDR     R2, [R0, #4]               \ Fetch the second word of the commander
 TST     R2, #&000000FF             \ name, convert any null bytes to carriage
 ORREQ   R2, R2, #&0000000D         \ returns and store the result in trName,
 TST     R2, #&0000FF00             \ making sure the last character is always
 ORREQ   R2, R2, #&00000D00         \ a carriage return
 TST     R2, #&00FF0000
 ORREQ   R2, R2, #&000D0000
 AND     R2, R2, #&00FFFFFF
 ORR     R2, R2, #&0D000000
 STR     R2, [R12, #trName+4]

 MOV     R3, #1                     \ Set R3 to 1 (for Offender)

 LDR     R0, cmdrLegal              \ Check to see if the commander's legal
 MOV     R1, R0                     \ status is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R2, [R0]                   \ Set R2 to the commander's legal status

 CMP     R2, #&28                   \ If R2 <= &28 then set R3 to 0 (for Clean)
 MOVLE   R3, #0

 CMP     R2, #&3E8                  \ If R2 > &3E8 then set R3 to 3 (for
 MOVGT   R3, #3                     \ Fugitive)

 STRB    R3, [R12, #trLegal]        \ Set byte #8 to the legal status

 LDR     R0, cmdrCondition          \ Check to see if the commander's condition
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R2, [R0]                   \ Set R2 to the commander's condition plus 1
 ADD     R2, R2, #1                 \ to give 1 = Green, 2 = Yellow, 3 = Red,
                                    \ 4 = Hyperspace, 5 = Witchspace, 6 = Docked

 CMP     R2, #4                     \ If condition is Hyperspace or Witchspace,
 CMPNE   R2, #5                     \ set R2 = 3 (for Red)
 MOVEQ   R2, #3

 CMP     R2, #6                     \ If condition is Docked, set R2 = 0
 MOVGE   R2, #0

 STRB    R2, [R12, #trCondition]    \ Set byte #9 to the condition

 LDRB    R2, [R12, #netTally]       \ Set byte #10 to the kill tally
 STRB    R2, [R12, #trKill]

 LDRB    R2, [R12, #netDeaths]      \ Set byte #10 to the death count
 STRB    R2, [R12, #trDeaths]

 LDR     R0, cmdrCredits            \ Check to see if the commander credits are
 MOV     R1, R0                     \ in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R2, [R0]                   \ Set bytes #12-15 to the commander credits
 STR     R2, [R12, #trCredits]

 MOV     R2, #4                     \ Set byte #16 to machine type 4
 STR     R2, [R12, #trMachine]

                                    \ We now check to see if the transmission
                                    \ is correctly configured

 LDR     R1, [R12, #scorePort]      \ Set R1 to the port number and R2 to the
 TEQ     R1, #0                     \ station number, setting the Z flag if
 LDRNE   R2, [R12, #scoreStation]   \ either of them is zero
 TEQNE   R2, #0

 BEQ     skipT                      \ If either of them is zero, jump to skipT
                                    \ to skip the transmission

                                    \ We now do the data transmission

 MOV     R0, #0                     \ Set R0 to the flag byte

                                    \ R1 is already set to the port number

                                    \ R2 is already set to the station number

 LDR     R3, [R12, #scoreNetwork]   \ Set R3 to the network number

 ADD     R4, R12, #transmitBuffer   \ Set R4 to the buffer address

 MOV     R5, #20                    \ Set R5 to the buffer size

 MOV     R6, #1                     \ Set R6 to send this once

 MOV     R7, #0                     \ Set R7 to no delay

 SWI     XEconet_StartTransmit      \ Transmit the packet

 MOVVS   R0, #0                     \ If the call was not successful, zero the
                                    \ handle in R0

 STR     R0, [R12, #econetHandle]   \ Store the handle for this transmission

.skipT

 MOV     R0, #0                     \ Set the semaphore flag to zero to indicate
 STR     R0, [R12, #semaphore]      \ that we have finished this transmission

.doneT

 LDMFD   R13!, {R5, R14}            \ Restore R14_svc and R5 from the stack, so
                                    \ the latter contains the original processor
                                    \ mode from when we called this routine

 TEQP    R5, #0                     \ Set the processor mode to the original
 MOV     R0, R0                     \ mode in R5

 LDMFD   R13!, {R0-R12}             \ Retrieve the registers that we stored on
                                    \ the stack

 MOV     PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MonitorRank
\       Type: Subroutine
\   Category: Econet
\    Summary: Check the commander's rank and increase the net tally if it has
\             increased since last time
\
\ ******************************************************************************

.MonitorRank

 STMFD   R13!, {R0-R12}             \ Store the registers that we want to use on
                                    \ the stack so they can be preserved

                                    \ As we are calling this routine via the
                                    \ ticker event list the system will call the
                                    \ routine in SVC mode with interrupts
                                    \ disabled, so for us to be able to call
                                    \ SWIs, we need to save R14_svc on the stack
                                    \ to prevent corruption of the return
                                    \ address
                                    \
                                    \ Just to be on the safe side, we won't
                                    \ assume the processor mode that we are in,
                                    \ we'll just save that too so we can revert
                                    \ when we're done

 MOV     R5, PC                     \ Extract the current processor mode into R5
 BIC     R4, R5, #3                 \ from bits 0 and 1 of the program counter

 TEQP    R4, #3                     \ Switch to SVC mode
 MOV     R0, R0

 STMFD   R13!, {R5, R14}            \ Store the original processor mode (in R5)
                                    \ and R14_svc on the stack, so we can revert
                                    \ both of them when we are done

 LDR     R0, string1Addr            \ Check to see if the first string to match
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM

 LDR     R0, [R0]                   \ If the first string doesn't match, jump
 LDR     R1, string1Match           \ to skipM to return from the subroutine as
 CMP     R0, R1                     \ Elite is not paged in
 BNE     skipM

 LDR     R0, string2Addr            \ Check to see if the second string to match
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM

 LDR     R0, [R0]                   \ If the second string doesn't match, jump
 LDR     R1, string2Match           \ to skipM to return from the subroutine as
 CMP     R0, R1                     \ Elite is not paged in
 BNE     skipM

 LDR     R0, string3Addr            \ Check to see if the third string to match
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM

 LDR     R0, [R0]                   \ If the third string doesn't match, jump
 LDR     R1, string3Match           \ to skipM to return from the subroutine as
 CMP     R0, R1                     \ Elite is not paged in
 BNE     skipM

                                    \ If we get here then Elite is paged in

 LDR     R1, [R12, #patchApplied]   \ Set R1 to the patchApplied flag

 TEQ     R1, #1                     \ If R1 = 1 then we have already applied the
 BEQ     skipP                      \ patch, so skip the following

 LDR     R0, gameOverAddr           \ Deploy the first GAME OVER patch if the
 MOV     R1, R0                     \ address is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM
 LDR     R1, gameOverPatch
 STR     R1, [R0]

 LDR     R0, restartAddr            \ Deploy the second GAME OVER patch if the
 MOV     R1, R0                     \ address is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM
 LDR     R1, restartPatch
 STR     R1, [R0]

 MOV     R1, #1                     \ Set the patchApplied flag to 1 to denote
 STR     R1, [R12, #patchApplied]   \ that the game over patch has been applied

.skipP

 LDR     R0, cmdrRank               \ Check to see if the commander's rank is in
 MOV     R1, R0                     \ logical RAM
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM

 LDR     R1, [R12, #currentRank]    \ Set R1 to the last rank that we recorded

 LDR     R2, [R0]                   \ Set R2 to the commander's rank from the
 STR     R2, [R12, #currentRank]    \ game and store it in currentRank

 CMN     R1, #1                     \ If this is the first rank we have fetched
 BEQ     skipM                      \ then R1 will be -1, so jump to skipM to
                                    \ skip the comparison with last time

 CMP     R2, R1                     \ If the new rank in R2 is greater than the
 LDRGT   R3, [R12, #netTally]       \ previous rank in R1, increase the kill
 ADDGT   R3, R3, #1                 \ tally
 STRGT   R3, [R12, #netTally]

.skipM

 LDMFD   R13!, {R5, R14}            \ Restore R14_svc and R5 from the stack, so
                                    \ the latter contains the original processor
                                    \ mode from when we called this routine

 TEQP    R5, #0                     \ Set the processor mode to the original
 MOV     R0, R0                     \ mode in R5

 LDMFD   R13!, {R0-R12}             \ Retrieve the registers that we stored on
                                    \ the stack

 MOV     PC, R14                    \ Return from the subroutine


\ ******************************************************************************
\
\       Name: Archimedes Elite addresses (version 1.14)
\       Type: Workspace
\   Category: Econet
\    Summary: Addresses for the commander data and version strings in Elite
\
\ ******************************************************************************

.cmdrName

 EQUD    &0005A698

.cmdrRank

 EQUD    &0005A960

.cmdrCredits

 EQUD    &0006534C

.cmdrLegal

 EQUD    &00065398

.cmdrCondition

 EQUD    &000653A0

.string1Addr

 EQUD    &0001AF14

.string1Match

 EQUD    &4E495247                  \ GRIN (part of "CLIVE GRINGRAS")

.string2Addr

 EQUD    &0001AF00

.string2Match

 EQUD    &45525241                  \ ARRE (part of "WARREN BURCH")

.string3Addr

 EQUD    &00071508

.string3Match

 EQUD    &34312E31                  \ 1.14 (part of "Version 1.14")

.gameOverAddr

 EQUD    &0000BBD0

.gameOverPatch

 SWI     XElite_GameOver            \ Replaces MOV R0, #&29

.restartAddr

 EQUD    &0001AF24

.restartPatch

 SWI     XElite_GameRestart         \ Replaces MOV R2, #&12C

\ ******************************************************************************
\
\ Two-pass assembly loop
\
\ ******************************************************************************

]

 NEXT pass%                         \ Loop back for the second pass

\ ******************************************************************************
\
\ Save EliteNet.bin
\
\ ******************************************************************************

 OSCLI "SAVE EliteNet.bin "+STR$~CODE%+" "+STR$~O%+" "+STR$~CODE+" "+STR$~CODE
