\ ******************************************************************************
\
\ ELITE OVER ECONET SCOREBOARD MODULE SOURCE
\
\ The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
\ in the documentation are entirely my fault
\
\ The terminology and notations used in this commentary are explained at
\ https://elite.bbcelite.com/terminology
\
\ The deep dive articles referred to in this commentary can be found at
\ https://elite.bbcelite.com/deep_dives
\
\ ------------------------------------------------------------------------------
\
\ This source file produces the following binary file:
\
\   * Scoreboard.bin
\
\ ******************************************************************************

 CODE = &00000000                   \ The build address for the Module

\ ******************************************************************************
\
\ Operating system SWI numbers
\
\ ******************************************************************************

 XOS_Module = &2001E                \ The operating system call for claiming
                                    \ workspace for a module

 XOS_ValidateAddress = &2003A       \ The operating system call to check whether
                                    \ an address range is in logical RAM

 XOS_CallEvery = &2003C             \ The operating system call to call a
                                    \ routine regularly

 XOS_RemoveTickerEvent = &2003D     \ The operating system call to remove a call
                                    \ set up by OS_CallEvery

 XEconet_StartTransmit = &60006     \ The operating system call to create a
                                    \ Transmit Control Block and start a
                                    \ transmission over Econet

 XEconet_AbandonTransmit = &60008   \ The operating system call to abandon a
                                    \ Transmit Control Block and reclaim the
                                    \ memory

\ ******************************************************************************
\
\ Econet variables
\
\ ******************************************************************************

                                    \ R12 typically contains the address of the
                                    \ module's private workspace, so each of the
                                    \ variables in the workspace can be referred
                                    \ to as:
                                    \
                                    \   [R12, #offset]
                                    \
                                    \ where #offset is one of the following
                                    \ variables

 scorePort = &00                    \ The Econet port on which to talk to the
                                    \ scoreboard machine
                                    \
                                    \ If this is zero, the network is disabled
                                    \ and no commander data is transmitted

 scoreStation = &04                 \ The station number of the scoreboard
                                    \ machine

 scoreNetwork = &08                 \ The network number of the scoreboard
                                    \ machine

 currentRank = &0C                  \ The current commander rank, so we can
                                    \ track it

 netTally = &10                     \ Stores a one-point-per-kill combat score
                                    \ for the scoreboard (so all platforms have
                                    \ the same point system)

 netDeaths = &14                    \ Counts the number of deaths

 econetHandle = &18                 \ The handle of the last packet transmission

 semaphore = &30                    \ A flag to stop us from starting a new
                                    \ transmission before we have finished the
                                    \ current one

 transmitBuffer = &20               \ The tramsmit buffer

 trName = &20                       \ Bytes #0-7 = commander's name, terminated
                                    \ by a carriage return

 trLegal = &28                      \ Byte #8 = commander's legal status
                                    \ 0 = clean, 1 = offender, 2 = fugitive

 trCondition = &29                  \ Byte #9 = commander's status condition
                                    \ 0 = docked, 1 = green, 2 = yellow, 3 = red

 trKill = &2A                       \ Byte #10 = commander's kill count

 trDeaths = &2B                     \ Byte #11 = commander's death count

 trCredits = &2C                    \ Bytes #12-15 = commander's credits

 trMachine = &30                    \ Byte #16 = machine type
                                    \    0 = BBC Micro SRAM, 1 = Master,
                                    \    2 = 6502SP, 3 = BBC Micro standard
                                    \    4 = Archimedes

 endOfBuffer = &34

\ ******************************************************************************
\
\ ELITE OVER ECONET SCOREBOARD MODULE CODE
\
\ Produces the binary file Scoreboard.bin.
\
\ ******************************************************************************

 DIM CODE% &1000                    \ Reserve a block in memory for the
                                    \ assembled code

 FOR pass% = 4 TO 6 STEP 2          \ Perform a two-pass assembly, using both
                                    \ P% and O%, with errors enabled on the
                                    \ second pass only

 O% = CODE%                         \ Assemble the code for deployment to
                                    \ address O%

 P% = CODE                          \ Assemble the code into the block at P%

[                                   \ Switch from BASIC into assembly language

 OPT    pass%                       \ Set the assembly option for this pass

\ ******************************************************************************
\
\       Name: Module header
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Relocatable module header
\
\ ******************************************************************************

 EQUD    0                          \ Offset to start code

 EQUD    InitialiseModule           \ Offset to initialisation code

 EQUD    FinaliseModule             \ Offset to finalisation code

 EQUD    0                          \ Offset to service call handler

 EQUD    title                      \ Offset to title string

 EQUD    help                       \ Offset to help string

 EQUD    0                          \ Offset to help and command keyword table

\ ******************************************************************************
\
\       Name: Module title
\       Type: Variable
\   Category: Scoreboard
\    Summary: Relocatable module title string
\
\ ******************************************************************************

.title

 EQUS    "EliteScoreboard"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: Module help text
\       Type: Variable
\   Category: Scoreboard
\    Summary: Relocatable module help string
\
\ ******************************************************************************

.help

 EQUS    "EliteScoreboard"
 EQUB    9
 EQUS    "1.00 (26 Mar 2025)"
 EQUB    0
 ALIGN

\ ******************************************************************************
\
\       Name: InitialiseModule
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Initialise the module
\
\ ******************************************************************************

.InitialiseModule

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R2, [R12]                  \ Set R2 to the module's private word

 TEQ     R2, #0                     \ If the private word is non-zero then we
 BNE     init1                      \ have already set up the module's private
                                    \ workspace and the private word contains
                                    \ the address of that workspace, so jump to
                                    \ init1 to skip the following, with the
                                    \ address of the workspace in R2

                                    \ If we get here then the module's workspace
                                    \ has not been set up, so we do that now

 MOV     R0, #6                     \ Claim &40 bytes of workspace, returning
 MOV     R3, #&40                   \ the address of the workspace in R2
 SWI     XOS_Module

 LDMVSFD R13!, {PC}                 \ If the C flag is set then the claim has
                                    \ failed and the module can't be run, so
                                    \ return without initialising the module

 STR     R2, [R12]                  \ Otherwise the claim was successful, so set
                                    \ the module's private word to the address
                                    \ of the claimed memory

 MOV     R1, #0                     \ Reset the handle of the previous packet as
 STR     R1, [R2, #econetHandle]    \ there isn't one

 STR     R1, [R2, #netTally]        \ Zero the kill tally

 STR     R1, [R2, #netDeaths]       \ Zero the death count

 STR     R1, [R2, #currentRank]     \ Reset the current rank, as we haven't yet
                                    \ fetched it from the game

 STR     R1, [R2, #scoreNetwork]    \ Zero the scoreboard network details
 STR     R1, [R2, #scoreStation]
 STR     R1, [R2, #scorePort]

                                    \ >>> HARD-CODED VALUES, need to change
                                    \ these to *-commands

 STR     R1, [R2, #scoreNetwork]    \ Set scoreboard to 0.128:100
 MOV     R1, #100
 STR     R1, [R2, #scorePort]
 MOV     R1, #128
 STR     R1, [R2, #scoreStation]

.init1

 MOV     R0, #100                   \ Add a call to the TransmitData routine
 ADR     R1, TransmitData           \ into the ticker event list so it gets
 SWI     XOS_CallEvery              \ called every one second (set as 100
                                    \ centiseconds), to transmit the commander
                                    \ data to the scoreboard
                                    \
                                    \ Note that R2 contains the address of the
                                    \ module's private workspace, so this will
                                    \ be sent to the routine in R12 whenever it
                                    \ is called

 LDMFD   R13!, {PC}^                \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FinaliseModule
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Finalise the module
\
\ ******************************************************************************

.FinaliseModule

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 ADR     R0, TransmitData           \ Remove the TransmitData routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called (we set R1 to the address of the
                                    \ module's private workspace so it matches
                                    \ the value of R2 that was used when adding
                                    \ the routine to the ticker list)

 LDR     R0, [R12, #econetHandle]   \ Fetch the handle of the previous packet

 TEQ     R0, #0                     \ If there is a handle, abandon the previous
 SWINE   XEconet_AbandonTransmit    \ transmission to recover its memory from
                                    \ the RMA

 MOV     R1, #0                     \ Reset the handle of the previous packet
 STR     R1, [R12, #econetHandle]

 LDMFD   R13!, {PC}^                \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TransmitData
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Create and send an Econet data packet
\
\ ******************************************************************************

.TransmitData

 STMFD   R13!, {R0-R12}             \ Store the registers that we want to use on
                                    \ the stack so they can be preserved

                                    \ As we are calling this routine via the
                                    \ ticker event list the system will call the
                                    \ routine in SVC mode with interrupts
                                    \ disabled, so for us to be able to call
                                    \ SWIs, we need to save R14_svc on the stack
                                    \ to prevent corruption of the return
                                    \ address
                                    \
                                    \ Just to be on the safe side, we won't
                                    \ assume the processor mode that we are in,
                                    \ we'll just save that too so we can revert
                                    \ when we're done

 MOV     R5, PC                     \ Extract the current processor mode into R5
 BIC     R4, R5, #3                 \ from bits 0 and 1 of the program counter

 TEQP    R4, #3                     \ Switch to SVC mode
 MOV     R0, R0

 STMFD   R13!, {R5, R14}            \ Store the original processor mode (in R5)
                                    \ and R14_svc on the stack, so we can revert
                                    \ both of them when we are done

 LDR     R0, [R12, #semaphore]      \ ???
 TEQ     R0, #0
 BNE     done

 MOV     R0, #1                     \ ???
 STR     R0, [R12, #semaphore]

 LDR     R0, [R12, #econetHandle]   \ Fetch the handle of the previous packet

 TEQ     R0, #0                     \ If there is a handle, abandon the previous
 SWINE   XEconet_AbandonTransmit    \ transmission to recover its memory from
                                    \ the RMA

 LDR     R0, cmdrName               \ Check to see if the commander name is in
 ADD     R1, R0, #4                 \ logical RAM
 SWI     XOS_ValidateAddress

 BVS     done
 BCS     done

 LDR     R2, [R0]                   \ Set bytes #0-7 of the buffer to the
 STR     R2, [R12, #trName]         \ null-terminated commander name (which
 LDR     R2, [R0, #4]               \ may be longer, so we just fetch the first
 STR     R2, [R12, #trName+4]       \ eight characters)

 MOV     R2, #13                    \ Ensure the commander name is no more than
 STRB    R2, [R12, #trName+7]       \ seven characters with a carriage return at
                                    \ the end

 LDRB    R3, [R12, #trName+6]       \ Convert any null bytes in the commander
 TEQ     R3, #0
 STREQB  R2, [R12, #trName+6]       \ name to carriage returns, so we know the
 LDRB    R3, [R12, #trName+5]       \ name is CR-terminated
 TEQ     R3, #0
 STREQB  R2, [R12, #trName+5]
 LDRB    R3, [R12, #trName+4]
 TEQ     R3, #0
 STREQB  R2, [R12, #trName+4]
 LDRB    R3, [R12, #trName+3]
 TEQ     R3, #0
 STREQB  R2, [R12, #trName+3]
 LDRB    R3, [R12, #trName+2]
 TEQ     R3, #0
 STREQB  R2, [R12, #trName+2]
 LDRB    R3, [R12, #trName+1]
 TEQ     R3, #0
 STREQB  R2, [R12, #trName+1]
 LDRB    R3, [R12, #trName]
 TEQ     R3, #0
 STREQB  R2, [R12, #trName]

 MOV     R3, #1                     \ Set R3 to 1 (for Offender)

 LDR     R0, cmdrLegal              \ Check to see if the commander's legal
 MOV     R1, R0                     \ status is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     done
 BCS     done

 LDR     R2, [R0]                   \ Set R2 to the commander's legal status

 CMP     R2, #&28                   \ If R2 <= &28 then set R3 to 0 (for Clean)
 MOVLE   R3, #0

 CMP     R2, #&3E8                  \ If R2 > &3E8 then set R3 to 3 (for
 MOVGT   R3, #3                     \ Fugitive)

 STRB    R3, [R12, #trLegal]        \ Set byte #8 to the legal status

 LDR     R0, cmdrCondition          \ Check to see if the commander's condition
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     done
 BCS     done

 LDR     R2, [R0]                   \ Set R2 to the commander's condition plus 1
 ADD     R2, R2, #1                 \ to give 1 = Green, 2 = Yellow, 3 = Red,
                                    \ 4 = Hyperspace, 5 = Witchspace, 6 = Docked

 CMP     R2, #4                     \ If condition is Hyperspace or Witchspace,
 CMPNE   R2, #5                     \ set R2 = 3 (for Red)
 MOVEQ   R2, #3

 CMP     R2, #6                     \ If condition is Docked, set R2 = 0
 MOVGE   R2, #0

 STRB    R2, [R12, #trCondition]    \ Set byte #9 to the legal status

 LDRB    R2, [R12, #netTally]       \ Set byte #10 to the kill tally
 STRB    R2, [R12, #trKill]

 LDRB    R2, [R12, #netDeaths]      \ Set byte #10 to the death count
 STRB    R2, [R12, #trDeaths]

 LDR     R0, cmdrCredits            \ Check to see if the commander credits are
 MOV     R1, R0                     \ in logical RAM
 SWI     XOS_ValidateAddress
 BVS     done
 BCS     done

 LDR     R2, [R0]                   \ Set bytes #12-15 to the commander credits
 STR     R2, [R12, #trCredits]
 
 MOV     R2, #4                     \ Set byte #16 to machine type 4
 STR     R2, [R12, #trMachine]

                                    \ We now do the data transmission

 MOV     R0, #0                     \ Set R0 to the flag byte

 LDR     R1, [R12, #scorePort]      \ Set R1 to the port number

 LDR     R2, [R12, #scoreStation]   \ Set R2 to the station number

 LDR     R3, [R12, #scoreNetwork]   \ Set R3 to the network number

 ADD     R4, R12, #transmitBuffer   \ Set R4 to the buffer address

 MOV     R5, #20                    \ Set R5 to the buffer size

 MOV     R6, #1                     \ Set R6 to send this once

 MOV     R7, #0                     \ Set R7 to no delay

 SWI     XEconet_StartTransmit      \ Transmit the packet

 MOVVS   R0, #0                     \ If the call was not successful, zero the
                                    \ handle in R0

 STR     R0, [R12, #econetHandle]   \ Store the handle for this transmission

.done

 MOV     R0, #0                     \ ???
 STR     R0, [R12, #semaphore]

 LDMFD   R13!, {R5, R14}            \ Restore R14_svc and R5 from the stack, so
                                    \ the latter contains the original processor
                                    \ mode from when we called this routine

 TEQP    R5, #0                     \ Set the processor mode to the original
 MOV     R0, R0                     \ mode in R5

 LDMFD   R13!, {R0-R12}             \ Retrieve the registers that we stored on
                                    \ the stack

 MOV     PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Archimedes Elite addresses (version 1.14)
\       Type: Workspace
\   Category: Econet
\    Summary: Addresses for the commander data in Elite
\
\ ******************************************************************************

.cmdrName

 EQUD    &5A698

.cmdrRank

 EQUD    &5A960

.cmdrCredits

 EQUD    &6534C

.cmdrLegal

 EQUD    &65398

.cmdrCondition

 EQUD    &653A0

\ ******************************************************************************
\
\ Two-pass assembly loop
\
\ ******************************************************************************

 ]

 NEXT pass%                         \ Loop back for the second pass

\ ******************************************************************************
\
\ Save Scoreboard.bin
\
\ ******************************************************************************

 OSCLI "SAVE Scoreboard.bin "+STR$~CODE%+" "+STR$~O%+" "+STR$~CODE+" "+STR$~CODE
