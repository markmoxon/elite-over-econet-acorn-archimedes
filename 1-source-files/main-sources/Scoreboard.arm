\ ******************************************************************************
\
\ ELITE OVER ECONET SCOREBOARD MODULE SOURCE
\
\ The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
\ in the documentation are entirely my fault
\
\ The terminology and notations used in this commentary are explained at
\ https://elite.bbcelite.com/terminology
\
\ The deep dive articles referred to in this commentary can be found at
\ https://elite.bbcelite.com/deep_dives
\
\ ------------------------------------------------------------------------------
\
\ This source file produces the following binary file:
\
\   * Scoreboard.bin
\
\ ******************************************************************************

 CODE = &00000000                   \ The build address for the Module

\ ******************************************************************************
\
\ Operating system SWI numbers
\
\ ******************************************************************************

 XOS_Module = &2001E                \ The operating system call for claiming
                                    \ workspace for a module

 XOS_Claim = &2001F                 \ The operating system call to add a routine
                                    \ to the list of those that claim a vector

 XOS_Release = &20020               \ The operating system call to remove a
                                    \ routine from the list of those that claim
                                    \ a vector

 XOS_ValidateAddress = &2003A       \ The operating system call to check whether
                                    \ an address range is in logical RAM

 XEconet_StartTransmit = &60006     \ The operating system call to create a
                                    \ Transmit Control Block and start a
                                    \ transmission

 XEconet_AbandonTransmit = &60008   \ The operating system call to abandon a
                                    \ Transmit Control Block and reclaim the
                                    \ memory

\ ******************************************************************************
\
\ Econet variables
\
\ ******************************************************************************

 scorePort = &0                     \ The Econet port on which to talk to the
                                    \ scoreboard machine
                                    \
                                    \ If this is zero, the network is disabled
                                    \ and no commander data is transmitted

 scoreStation = &04                 \ The station number of the scoreboard
                                    \ machine

 scoreNetwork = &08                 \ The network number of the scoreboard
                                    \ machine

 currentRank = &0C                  \ The current commander rank, so we can
                                    \ track it

 netTally = &10                     \ Stores a one-point-per-kill combat score
                                    \ for the scoreboard (so all platforms have
                                    \ the same point system)

 netDeaths = &14                    \ Counts the number of deaths

 econetHandle = &18                 \ The handle of the last packet transmission

 transmitBuffer = &1C               \ The tramsmit buffer

 trName = &1C                       \ Bytes #0-7 = commander's name, terminated
                                    \ by a carriage return

 trLegal = &24                      \ Byte #8 = commander's legal status
                                    \ 0 = clean, 1 = offender, 2 = fugitive

 trCondition = &25                  \ Byte #9 = commander's status condition
                                    \ 0 = docked, 1 = green, 2 = yellow, 3 = red

 trKill = &26                       \ Byte #10 = commander's kill count

 trDeaths = &27                     \ Byte #11 = commander's death count

 trCredits = &28                    \ Bytes #12-15 = commander's credits

 trMachine = &2C                    \ Byte #16 = machine type
                                    \    0 = BBC Micro SRAM, 1 = Master,
                                    \    2 = 6502SP, 3 = BBC Micro standard
                                    \    4 = Archimedes

 endOfBuffer = &30

\ ******************************************************************************
\
\ ELITE OVER ECONET SCOREBOARD MODULE CODE
\
\ Produces the binary file Scoreboard.bin.
\
\ ******************************************************************************

 DIM CODE% &1000                    \ Reserve a block in memory for the
                                    \ assembled code

 FOR pass% = 4 TO 6 STEP 2          \ Perform a two-pass assembly, using both
                                    \ P% and O%, with errors enabled on the
                                    \ second pass only

 O% = CODE%                         \ Assemble the code for deployment to
                                    \ address O%

 P% = CODE                          \ Assemble the code into the block at P%

 [                                  \ Switch from BASIC into assembly language

 OPT pass%                          \ Set the assembly option for this pass

\ ******************************************************************************
\
\       Name: Module header
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Relocatable module header
\
\ ******************************************************************************

 EQUD 0                             \ Offset to start code

 EQUD InitialiseModule              \ Offset to initialisation code

 EQUD FinaliseModule                \ Offset to finalisation code

 EQUD 0                             \ Offset to service call handler

 EQUD title                         \ Offset to title string

 EQUD help                          \ Offset to help string

 EQUD 0                             \ Offset to help and command keyword table

\ ******************************************************************************
\
\       Name: Module title
\       Type: Variable
\   Category: Scoreboard
\    Summary: Relocatable module title string
\
\ ******************************************************************************

.title

 EQUS "EliteScoreboard"
 EQUB 0
 ALIGN

\ ******************************************************************************
\
\       Name: Module help text
\       Type: Variable
\   Category: Scoreboard
\    Summary: Relocatable module help string
\
\ ******************************************************************************

.help

 EQUS "EliteScoreboard"
 EQUB 9
 EQUS "1.00 (26 Mar 2025)"
 EQUB 0
 ALIGN

\ ******************************************************************************
\
\       Name: InitialiseModule
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Initialise the module
\
\ ******************************************************************************

.InitialiseModule

 STMFD   R13!, {R14}                \ Store the registers that we want to use on
                                    \ the stack so they can be preserved

 MOV     R0, #6                     \ Reserve &40 bytes of workspace, returning
 MOV     R3, #&40                   \ the address of the workspace in R2
 SWI     XOS_Module

 BVS     init1                      \ If the claim fails, jump to init1 to
                                    \ return from the subroutine without
                                    \ initialising the module

 STR     R2, [R12]                  \ Update the module's private word to point
                                    \ to the claimed memory

                                    \ HARD-CODED VALUES

 MOV     R1, #100
 STR     R1, [R2, #scorePort]

 MOV     R1, #128
 STR     R1, [R2, #scoreStation]

 MOV     R1, #0
 STR     R1, [R2, #scoreNetwork]

\LDR     R0, cmdrRank               \ Initialise currentRank with the current
\ADR     R1, currentRank            \ kill score for the commander
\LDR     R2, [R0]
\STR     R2, [R1]

 MOV     R0, #&10                   \ Set R0 to the number of the EventV vector

 ADR     R1, RunScoreboard          \ Set R1 to the address of RunScoreboard
                                    \ routine that handles the event

 MOV     R2, R12                    \ Set R2 = R12 so the address of the private
                                    \ word so gets passed to the handler in R12

 SWI     XOS_Claim                  \ Add the RunScoreboard to the list of
                                    \ routines claiming the event vector

 LDMFD   R13!, {PC}^                \ Retrieve the registers that we stored on
                                    \ the stack and return from the subroutine

.init1

 LDMFD   R13!, {PC}                 \ Retrieve the registers that we stored on
                                    \ the stack and return from the subroutine,
                                    \ but without affecting the V flag

\ ******************************************************************************
\
\       Name: FinaliseModule
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Finalise the module
\
\ ******************************************************************************

.FinaliseModule

 STMFD   R13!, {R14}                \ Store the registers that we want to use on
                                    \ the stack so they can be preserved

 MOV     R0, #&10                   \ Set R0 to the number of the EventV vector

 ADR     R1, RunScoreboard          \ Set R1 to the address of RunScoreboard
                                    \ routine that handles the event

 MOV     R2, R12                    \ Set R2 = R12 so the address of the private
                                    \ word so gets passed to the handler in R12

 SWI     XOS_Release                \ Remove RunScoreboard from the list of
                                    \ routines claiming the event vector

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 LDR     R0, [R12, #econetHandle]   \ Fetch the handle of the previous packet

 SWINE   XEconet_AbandonTransmit    \ If there is a handle, abandon the previous
                                    \ transmission to recover its memory from
                                    \ the RMA

 LDMFD   R13!, {PC}^                \ Retrieve the registers that we stored on
                                    \ the stack and return from the subroutine

\ ******************************************************************************
\
\       Name: RunScoreboard
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Check for F1 and tally increments
\
\ ******************************************************************************

.RunScoreboard

 STMFD   R13!, {R0-R7}              \ Store the registers that we want to use on
                                    \ the stack so they can be preserved

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

\LDR     R0, cmdrRank               \ If the commander's tally has increased
\ADR     R1, currentRank            \ since the last time we were here, bump up
\LDR     R2, [R0]                   \ the kill tally and transmit the new score
\LDR     R3, [R1]
\CMP     R2, R3
\ADRGT   R0, netTally
\LDRGT   R1, [R0]
\ADDGT   R1, R1, #1
\STRGT   R1, [R0]
\BGT     TransmitData

\LDMFD   R13, {R0-R7}               \ Retrieve the registers that we stored on
                                    \ the stack and return from the subroutine,
                                    \ leaving them on the stack, so R0 to R2 now
                                    \ contain the event details

 TEQ     R0, #11                    \ Is this the key up/down event?

 TEQEQ   R1, #1                     \ Is this the key down event

 TEQEQ   R2, #&0B                   \ Is key &0C (F11) being pressed down?

 BEQ     TransmitData               \ If so, jump to TransmitData

 LDMFD   R13!, {R0-R7}              \ Retrieve the registers that we stored on
                                    \ the stack and return from the subroutine

 MOVS    PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TransmitData
\       Type: Subroutine
\   Category: Scoreboard
\    Summary: Create and send an Econet data packet
\
\ ******************************************************************************

.TransmitData

 LDR     R0, [R12, #econetHandle]   \ Fetch the handle of the previous packet

 SWINE   XEconet_AbandonTransmit    \ If there is a handle, abandon the previous
                                    \ transmission to recover its memory from
                                    \ the RMA

 LDR     R0, cmdrName               \ Check to see if the commander name is in
 ADD     R1, R0, #4                 \ logical RAM
 SWI     XOS_ValidateAddress
 BVS     done
 BCS     done

 LDR     R2, [R0]                   \ Set bytes #0-7 of the buffer to the
 STR     R2, [R12, #trName]         \ null-terminated commander name (which
 LDR     R2, [R0, #4]               \ may be longer, so we just fetch the first
 STR     R2, [R12, #trName+4]       \ eight characters)

 MOV     R2, #13                    \ Ensure the commander name is no more than
 STRB    R2, [R12, #trName+7]       \ seven characters with a carriage return at
                                    \ the end

 LDRB    R3, [R12, #trName+6]       \ Convert any null bytes in the commander
 STRBEQ  R2, [R12, #trName+6]       \ name to carriage returns, so we know the
 LDRB    R3, [R12, #trName+5]       \ name is CR-terminated
 STRBEQ  R2, [R12, #trName+5]
 LDRB    R3, [R12, #trName+4]
 STRBEQ  R2, [R12, #trName+4]
 LDRB    R3, [R12, #trName+3]
 STRBEQ  R2, [R12, #trName+3]
 LDRB    R3, [R12, #trName+2]
 STRBEQ  R2, [R12, #trName+2]
 LDRB    R3, [R12, #trName+1]
 STRBEQ  R2, [R12, #trName+1]
 MOV     R3, #1                     \ Set R3 to 1 (for Offender)

 LDR     R0, cmdrLegal              \ Check to see if the commander's legal
 MOV     R1, R0                     \ status is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     done
 BCS     done

 LDR     R2, [R0]                   \ Set R2 to the commander's legal status

 CMP     R2, #&28                   \ If R2 <= &28 then set R3 to 0 (for Clean)
 MOVLE   R3, #0

 CMP     R2, #&3E8                  \ If R2 > &3E8 then set R3 to 3 (for
 MOVGT   R3, #3                     \ Fugitive)

 STRB    R3, [R12, #trLegal]        \ Set byte #8 to the legal status

 LDR     R0, cmdrCondition          \ Check to see if the commander's condition
 MOV     R1, R0                     \ is in logical RAM
 SWI     XOS_ValidateAddress
 BVS     done
 BCS     done

 LDR     R2, [R0]                   \ Set R2 to the commander's condition plus 1
 ADD     R2, R2, #1                 \ to give 1 = Green, 2 = Yellow, 3 = Red,
                                    \ 4 = Hyperspace, 5 = Witchspace, 6 = Docked

 CMP     R2, #4                     \ If condition is Hyperspace or Witchspace,
 CMPNE   R2, #5                     \ set R2 = 3 (for Red)
 MOVEQ   R2, #3

 CMP     R2, #6                     \ If condition is Docked, set R2 = 0
 MOVGE   R2, #0

 STRB    R2, [R12, #trCondition]    \ Set byte #9 to the legal status

 LDRB    R2, [R12, #netTally]       \ Set byte #10 to the kill tally
 STRB    R2, [R12, #trKill]

 LDRB    R2, [R12, #netDeaths]      \ Set byte #10 to the death count
 STRB    R2, [R12, #trDeaths]

 LDR     R0, cmdrCredits            \ Check to see if the commander credits are
 MOV     R1, R0                     \ in logical RAM
 SWI     XOS_ValidateAddress
 BVS     done
 BCS     done

 LDR     R2, [R0]                   \ Set bytes #12-15 to the commander credits
 STR     R2, [R12, #trCredits]
 
 MOV     R2, #4                     \ Set byte #16 to machine type 4
 STR     R2, [R12, #trMachine]

                                    \ We now do the data transmission

 MOV     R0, #0                     \ Set R0 to the flag byte

 LDR     R1, [R12, #scorePort]      \ Set R1 to the port number

 LDR     R2, [R12, #scoreStation]   \ Set R2 to the station number

 LDR     R3, [R12, #scoreNetwork]   \ Set R3 to the network number

 ADD     R4, R12, #transmitBuffer   \ Set R4 to the buffer address

 MOV     R5, #20                    \ Set R5 to the buffer size

 MOV     R6, #1                     \ Set R6 to send this once

 MOV     R7, #0                     \ Set R7 to no delay

 SWI     XEconet_StartTransmit      \ Transmit the packet

 ADRVC   R1, econetHandle           \ If the SWI call was successful, store the
 STRVC   R0, [R12, #econetHandle]   \ handle for this transmission

.done

 LDMFD   R13!, {R0-R7}              \ Retrieve the registers that we stored on
                                    \ the stack and return from the subroutine

 MOVS    PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Archimedes Elite addresses (version 1.14)
\       Type: Workspace
\   Category: Econet
\    Summary: Addresses for the commander data in Elite
\
\ ******************************************************************************

.cmdrName

 EQUD &5A698

.cmdrRank

 EQUD &5A960

.cmdrCredits

 EQUD &6534C

.cmdrLegal

 EQUD &65398

.cmdrCondition

 EQUD &653A0

\ ******************************************************************************
\
\ Two-pass assembly loop
\
\ ******************************************************************************

 ]

 NEXT pass%                         \ Loop back for the second pass

\ ******************************************************************************
\
\ Save Scoreboard.bin
\
\ ******************************************************************************

 OSCLI "SAVE Scoreboard.bin "+STR$~CODE%+" "+STR$~O%+" "+STR$~CODE+" "+STR$~CODE
