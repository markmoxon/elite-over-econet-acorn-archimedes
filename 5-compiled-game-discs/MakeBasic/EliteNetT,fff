REM ******************************************************************************
REM
REM ELITE OVER ECONET MODULE SOURCE
REM
REM The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
REM in the documentation are entirely my fault
REM
REM The terminology and notations used in this commentary are explained at
REM https;//elite.bbcelite.com/terminology
REM
REM The deep dive articles referred to in this commentary can be found at
REM https;//elite.bbcelite.com/deep_dives
REM
REM ------------------------------------------------------------------------------
REM
REM This source file produces the following binary file;
REM
REM   * EliteNet
REM
REM ******************************************************************************

 CODE = &00000000                   : REM The build address for the Module

REM ******************************************************************************
REM
REM Operating system SWI numbers
REM
REM ******************************************************************************

 XOS_WriteC = &20000                : REM The operating system call for printing a
                                    : REM character

 XOS_Write0 = &20002                : REM The operating system call for printing a
                                    : REM null-terminated string

 XOS_Newline = &20003               : REM The operating system call for printing a
                                    : REM newline

 XOS_Module = &2001E                : REM The operating system call for claiming
                                    : REM workspace for a module

 XOS_EvaluateExpression = &2002D    : REM The operating system call to convert a
                                    : REM string into a number

 XOS_ValidateAddress = &2003A       : REM The operating system call to check whether
                                    : REM an address range is in logical RAM

 XOS_CallEvery = &2003C             : REM The operating system call to call a
                                    : REM routine regularly

 XOS_RemoveTickerEvent = &2003D     : REM The operating system call to remove a call
                                    : REM set up by OS_CallEvery

 XOS_ConvertCardinal1 = &200D5      : REM The operating system call for printing an
                                    : REM unsigned integer byte

 XOS_ConvertCardinal2 = &200D6      : REM The operating system call for printing an
                                    : REM unsigned integer 16-bit word

 XOS_ConvertCardinal4 = &200D8      : REM The operating system call for printing an
                                    : REM unsigned integer 32-bit word

 XOS_WriteI = &20100                : REM The operating system call for printing the
                                    : REM character specified in the SWI number

 XEconet_StartTransmit = &60006     : REM The operating system call to create a
                                    : REM Transmit Control Block and start a
                                    : REM transmission over Econet

 XEconet_AbandonTransmit = &60008   : REM The operating system call to abandon a
                                    : REM Transmit Control Block and reclaim the
                                    : REM memory

 XEconet_ReadStationNumber = &6000F : REM The operating system call to convert a
                                    : REM string into a network and station number

 XWimp_ReadSysInfo = &600F2         : REM The operating system call to fetch the
                                    : REM handle of the current task [amongst other
                                    : REM information]

 XMessageTrans_ErrorLookup = &61506 : REM The operating system call to expand tokens
                                    : REM in an error string

 XTaskManager_EnumerateTasks = &62681   : REM The operating system call to enumerate
                                        : REM task handles for running tasks

 XElite_GameOver = &E0CC0           : REM The SWI call to inject when the game
                                    : REM prints the GAME OVER string

 XElite_GameRestart = &E0CC1        : REM The SWI call to inject when the game
                                    : REM prints the copyright message on the title
                                    : REM screen

REM ******************************************************************************
REM
REM Econet variables
REM
REM ******************************************************************************

 startWorkspace = &00               : REM The start of the workspace

                                    : REM R12 typically contains the address of the
                                    : REM module's private workspace, so each of the
                                    : REM variables in the workspace can be referred
                                    : REM to as;
                                    : REM
                                    : REM   [R12, #offset]
                                    : REM
                                    : REM where #offset is one of the following
                                    : REM variables

 scorePort = &00                    : REM The Econet port on which to talk to the
                                    : REM scoreboard machine
                                    : REM
                                    : REM If this is zero, the network is disabled
                                    : REM and no commander data is transmitted

 scoreStation = &04                 : REM The station number of the scoreboard
                                    : REM machine

 scoreNetwork = &08                 : REM The network number of the scoreboard
                                    : REM machine

 currentRank = &0C                  : REM The current commander rank, so we can
                                    : REM track it

 netTally = &10                     : REM Stores a one-point-per-kill combat score
                                    : REM for the scoreboard [so all platforms have
                                    : REM the same point system]

 netDeaths = &14                    : REM Counts the number of deaths

 econetHandle = &18                 : REM The handle of the last packet transmission

 semaphore = &1C                    : REM A flag to stop us from starting a new
                                    : REM transmission before we have finished the
                                    : REM current one

 transmitBuffer = &20               : REM The tramsmit buffer

 trName = &20                       : REM Bytes #0-7 = commander's name, terminated
                                    : REM by a carriage return

 trLegal = &28                      : REM Byte #8 = commander's legal status;
                                    : REM
                                    : REM   * 0 = Clean
                                    : REM   * 1 = Offender
                                    : REM   * 2 = Fugitive

 trCondition = &29                  : REM Byte #9 = commander's status condition;
                                    : REM
                                    : REM   * 0 = Docked
                                    : REM   * 1 = Green
                                    : REM   * 2 = Yellow
                                    : REM   * 3 = Red

 trKillLo = &2A                     : REM Byte #10 = commander's kill count [low
                                    : REM byte]

 trDeaths = &2B                     : REM Byte #11 = commander's death count

 trCredits = &2C                    : REM Bytes #12-15 = commander's credits

 trMachine = &30                    : REM Byte #16 = machine type;
                                    : REM
                                    : REM   * 0 = BBC Micro SRAM
                                    : REM   * 1 = Master
                                    : REM   * 2 = 6502SP
                                    : REM   * 3 = BBC Micro standard
                                    : REM   * 4 = Archimedes

                                    : REM Bytes #17 and #18 contain the forwarding
                                    : REM machine station number, if applicable

 trKillHi = &33                     : REM Byte #19 = commander's kill count [high
                                    : REM byte]

 scoreEnabled = &34                 : REM Flag to control whether we transmit scores
                                    : REM to the scoreboard
                                    : REM
                                    : REM   * Zero = do not transmit scores
                                    : REM   * Non-zero = do transmit scores

 scoreInterval = &38                : REM The interval between score transmissions
                                    : REM in seconds

 stringBuffer = &3C                 : REM String buffer for processing command line
                                    : REM parameters [12 characters]

 gameIsOver = &48                   : REM A flag to determine whether the game is in
                                    : REM the process of ending

 patchApplied = &4C                 : REM A flag to determine whether the game over
                                    : REM patch has been applied

 taskHandle = &50                   : REM The task handle for Archimedes Elite

 taskBuffer = &54                   : REM A buffer for TaskManager_EnumerateTasks

 endWorkspace = &64                 : REM End of the private workspace

 workspaceSize = endWorkspace - startWorkspace  : REM The size of the workspace

REM ******************************************************************************
REM
REM ELITE OVER ECONET MODULE CODE
REM
REM Produces the binary file EliteNet.
REM
REM ******************************************************************************

 DIM CODE% &1000                    : REM Reserve a block in memory for the
                                    : REM assembled code

 FOR pass% = 4 TO 6 STEP 2          : REM Perform a two-pass assembly, using both
                                    : REM P% and O%, with errors enabled on the
                                    : REM second pass only

 O% = CODE%                         : REM Assemble the code for deployment to
                                    : REM address O%

 P% = CODE                          : REM Assemble the code into the block at P%

[                                   \ Switch from BASIC into assembly language

 OPT    pass%                       \ Set the assembly option for this pass

\ ******************************************************************************
\
\       Name; Module header
\       Type; Subroutine
\   Category; Econet
\    Summary; Relocatable module header
\
\ ******************************************************************************

 EQUD    0                          \ Offset to start code

 EQUD    InitialiseModule           \ Offset to initialisation code

 EQUD    FinaliseModule             \ Offset to finalisation code

 EQUD    0                          \ Offset to service call handler

 EQUD    title                      \ Offset to title string

 EQUD    help                       \ Offset to help string

 EQUD    helpAndCommandTable        \ Offset to help and command keyword table

 EQUD    &C0CC0                     \ SWI chunk base number

 EQUD    SWIHandler                 \ Offset to SWI handler code

 EQUD    swiDecodingTable           \ Offset to SWI decoding table

 EQUD    0                          \ Offset to SWI decoding code

\ ******************************************************************************
\
\       Name; Module title
\       Type; Variable
\   Category; Econet
\    Summary; Relocatable module title string
\
\ ******************************************************************************

.title

 EQUS    "EliteOverEconet"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; Module help text
\       Type; Variable
\   Category; Econet
\    Summary; Relocatable module help string
\
\ ******************************************************************************

.help

 EQUS    "EliteOverEconet"
 EQUB    9
 EQUS    "1.01 (11 May 2025)"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; Module help and command table
\       Type; Variable
\   Category; Econet
\    Summary; Relocatable module help and command table
\
\ ******************************************************************************

.helpAndCommandTable

                                    \ *EliteStatus

 EQUS    "EliteStatus"              \ String to match, null terminated
 EQUB    0
 OPT     FN_AlignWithZeroes

 EQUD    EliteStatus                \ Offset of code from module start

 EQUB    0                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    0                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteStatusHelp            \ Offset of help text

                                    \ *EliteTxStation <network>.<station>

 EQUS    "EliteTxStation"           \ String to match, null terminated
 EQUB    0
 OPT     FN_AlignWithZeroes

 EQUD    EliteTxStation             \ Offset of code from module start

 EQUB    1                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    1                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxStationHelp         \ Offset of help text

                                    \ *EliteTxPort <port>

 EQUS    "EliteTxPort"              \ String to match, null terminated
 EQUB    0
 OPT     FN_AlignWithZeroes

 EQUD    EliteTxPort                \ Offset of code from module start

 EQUB    1                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    1                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxPortHelp            \ Offset of help text

                                    \ *EliteTxInterval <interval>

 EQUS    "EliteTxInterval"          \ String to match, null terminated
 EQUB    0
 OPT     FN_AlignWithZeroes

 EQUD    EliteTxInterval            \ Offset of code from module start

 EQUB    1                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    1                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxIntervalHelp        \ Offset of help text

                                    \ *EliteTxStart

 EQUS    "EliteTxStart"             \ String to match, null terminated
 EQUB    0
 OPT     FN_AlignWithZeroes

 EQUD    EliteTxStart               \ Offset of code from module start

 EQUB    0                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    0                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxStartHelp           \ Offset of help text

                                    \ *EliteTxStop

 EQUS    "EliteTxStop"              \ String to match, null terminated
 EQUB    0
 OPT     FN_AlignWithZeroes

 EQUD    EliteTxStop                \ Offset of code from module start

 EQUB    0                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    0                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxStopHelp            \ Offset of help text

                                    \ *EliteTxReset

 EQUS    "EliteTxReset"             \ String to match, null terminated
 EQUB    0
 OPT     FN_AlignWithZeroes

 EQUD    EliteTxReset               \ Offset of code from module start

 EQUB    0                          \ Minimum number of parameters

 EQUB    0                          \ OS_GSTrans map

 EQUB    0                          \ Maximum number of parameters

 EQUB    0                          \ Flags

 EQUD    0                          \ Use default invalid syntax message

 EQUD    eliteTxResetHelp           \ Offset of help text

 EQUD    0                          \ End of command table

\ ******************************************************************************
\
\       Name; EliteTxPort
\       Type; Subroutine
\   Category; Econet
\    Summary; Implement the EliteTxPort command
\
\ ------------------------------------------------------------------------------
\
\ Other entry points;
\
\   EliteTxPort_SWI                 Entry point from the Elite_SetStatus SWI
\
\ ******************************************************************************

.EliteTxPort

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 ADD     R1, R12, #stringBuffer     \ Try converting the parameter to an integer
 MOV     R2, #12                    \ using the string buffer in the workspace
 SWI     XOS_EvaluateExpression

 BVS     port1                      \ Report an error if the conversion went
                                    \ wrong

 TEQ     R1, #0                     \ Report an error if the result is not an
 BNE     port1                      \ integer

.EliteTxPort_SWI

 CMP     R2, #1                     \ Report an error if the port number is not
 BLT     port1                      \ in the range 1 to 254
 CMP     R2, #254
 BGT     port1

 STR     R2, [R12, #scorePort]      \ Set scorePort to the new port number

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

 LDMFD   R13!, {PC}^                \ Return from the subroutine

.port1

 ADR     R0, eliteTxPortError       \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set [in bit 28 of the program counter]

.eliteTxPortError

 EQUD    255
 EQUS    "Invalid port number (it must be in the range 1 to 254)"
 EQUB    0
 OPT     FN_AlignWithZeroes

.eliteTxPortHelp

 EQUS    "*EliteTxPort sets the port number for transmitting scores."
 EQUB    13
 EQUS    "Syntax: *EliteTxPort <port>"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; EliteTxStation
\       Type; Subroutine
\   Category; Econet
\    Summary; Implement the EliteTxStation command
\
\ ------------------------------------------------------------------------------
\
\ Other entry points;
\
\   EliteTxStation_SWI              Entry point from the Elite_SetStatus SWI
\
\ ******************************************************************************

.EliteTxStation

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

.EliteTxStation_SWI

 MOV     R1, R0                     \ Try converting the parameter to a station
 SWI     XEconet_ReadStationNumber  \ and network number
 
 BVS     stat1                      \ Report the SWI error if the conversion
                                    \ went wrong, as this could mean that Econet
                                    \ is disabled

 CMN     R2, #1                     \ Report an error if the result does not
 BEQ     stat2                      \ contain a valid station number

 CMN     R3, #1                     \ Set R3 = 0 if the result does not contain
 MOVEQ   R3, #0                     \ a valid network number

 STR     R2, [R12, #scoreStation]   \ Set scoreNetwork to the new station number

 STR     R3, [R12, #scoreNetwork]   \ Set scoreNetwork to the new network number

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

.stat1

 LDMFD   R13!, {PC}^                \ Return from the subroutine

.stat2

 ADR     R0, eliteTxStationError    \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set [in bit 28 of the program counter]

.eliteTxStationError

 EQUD    255
 EQUS    "Invalid station (it must be in the format 123 or 1.234)"
 EQUB    0
 OPT     FN_AlignWithZeroes

.eliteTxStationHelp

 EQUS    "*EliteTxStation sets the network and station number "
 EQUS    "for transmitting scores."
 EQUB    13
 EQUS    "Syntax: *EliteTxStation [<network>.]<station>"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; EliteTxInterval
\       Type; Subroutine
\   Category; Econet
\    Summary; Implement the EliteTxInterval command
\
\
\ ------------------------------------------------------------------------------
\
\ Other entry points;
\
\   EliteTxInterval_SWI             Entry point from the Elite_SetStatus SWI
\
\ ******************************************************************************

.EliteTxInterval

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 ADD     R1, R12, #stringBuffer     \ Try converting the parameter to an integer
 MOV     R2, #12                    \ using the string buffer in the workspace
 SWI     XOS_EvaluateExpression

 BVS     intv2                      \ Report an error if the conversion went
                                    \ wrong

 TEQ     R1, #0                     \ Report an error if the result is not an
 BNE     intv2                      \ integer

.EliteTxInterval_SWI

 TEQ     R2, #0                     \ Report an error if the interval is zero
 BEQ     intv2

 STR     R2, [R12, #scoreInterval]  \ Set scoreInterval to the interval in
                                    \ seconds

 LDR     R1, [R12, #scoreEnabled]   \ Set R1 to the current enabled state

 TEQ     R1, #0                     \ If transmissions are stopped, jump to
 BEQ     intv1                      \ intv1 to skip the ticker event reset

 FN_ADRL(0, TransmitData)           \ Remove the TransmitData routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called [we set R1 to the address of the
                                    \ module's private workspace so it matches
                                    \ the value of R2 that was used when adding
                                    \ the routine to the ticker list]

 LDR     R0, [R12, #scoreInterval]  \ Add a call to the TransmitData routine
 MOV     R1, #100                   \ into the ticker event list so it gets
 MUL     R0, R1, R0                 \ called every scoreInterval seconds, to
 FN_ADRL(1, TransmitData)           \ transmit the commander data to the
 MOV     R2, R12                    \ scoreboard
 SWI     XOS_CallEvery

 BVS     star3                      \ If the event failed to start up, jump to
                                    \ star3 to report this 

.intv1

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

 LDMFD   R13!, {PC}^                \ Return from the subroutine

.intv2

 ADR     R0, eliteTxIntervalError   \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set [in bit 28 of the program counter]

.eliteTxIntervalError

 EQUD    255
 EQUS    "Invalid interval (it must be at least 1 second)"
 EQUB    0
 OPT     FN_AlignWithZeroes

.eliteTxIntervalHelp

 EQUS    "*EliteTxInterval sets the interval in seconds "
 EQUS    "between score transmissions."
 EQUB    13
 EQUS    "Syntax: *EliteTxInterval <interval>"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; EliteTxStop
\       Type; Subroutine
\   Category; Econet
\    Summary; Implement the EliteTxStop command
\
\ ------------------------------------------------------------------------------
\
\ Other entry points;
\
\   EliteTxStop_SWI                 Entry point from the Elite_SetStatus SWI
\
\ ******************************************************************************

.EliteTxStop

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

.EliteTxStop_SWI

 LDR     R1, [R12, #scoreEnabled]   \ Set R1 to the current enabled state

 TEQ     R1, #0                     \ If transmissions are already stopped, jump
 BEQ     stop1                      \ to stop1 to report this

 MOV     R0, #0                     \ Set scoreEnabled = 0 to denote that score
 STR     R0, [R12, #scoreEnabled]   \ transmissions are disabled

 FN_ADRL(0, TransmitData)           \ Remove the TransmitData routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called [we set R1 to the address of the
                                    \ module's private workspace so it matches
                                    \ the value of R2 that was used when adding
                                    \ the routine to the ticker list]

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

 LDMFD   R13!, {PC}^                \ Return from the subroutine

.stop1

 ADR     R0, eliteTxStopError       \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set [in bit 28 of the program counter]

.eliteTxStopError

 EQUD    255
 EQUS    "Transmissions are already disabled"
 EQUB    0
 OPT     FN_AlignWithZeroes

.eliteTxStopHelp

 EQUS    "*EliteTxStop disables score transmissions."
 EQUB    13
 EQUS    "Syntax: *EliteTxStop"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; EliteTxStart
\       Type; Subroutine
\   Category; Econet
\    Summary; Implement the EliteTxStart command
\
\ ------------------------------------------------------------------------------
\
\ Other entry points;
\
\   EliteTxStart_SWI                Entry point from the Elite_SetStatus SWI
\
\ ******************************************************************************

.EliteTxStart

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

.EliteTxStart_SWI

 LDR     R1, [R12, #scoreEnabled]   \ Set R1 to the current enabled state

 TEQ     R1, #1                     \ If transmissions are already started, jump
 BEQ     star1                      \ to star1 to report this

 LDR     R1, [R12, #scorePort]      \ Set R1 to the port number and R2 to the
 TEQ     R1, #0                     \ station number, setting the Z flag if
 LDRNE   R2, [R12, #scoreStation]   \ either of them is zero
 TEQNE   R2, #0

 BEQ     star2                      \ If either of them is zero, jump to star2
                                    \ to report this and prevent startup

 FN_ADRL(0, TransmitData)           \ Remove the TransmitData routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called [just to make sure there are no
                                    \ lingering ticker events from previous
                                    \ actions]

 LDR     R0, [R12, #scoreInterval]  \ Add a call to the TransmitData routine
 MOV     R1, #100                   \ into the ticker event list so it gets
 MUL     R0, R1, R0                 \ called every scoreInterval seconds, to
 FN_ADRL(1, TransmitData)           \ transmit the commander data to the
 MOV     R2, R12                    \ scoreboard
 SWI     XOS_CallEvery

 BVS     star3                      \ If the event failed to start up, jump to
                                    \ star3 to report this 

 MOV     R0, #1                     \ Set scoreEnabled = 1 to denote that score
 STR     R0, [R12, #scoreEnabled]   \ transmissions are enabled

 MOV     R0, #0                     \ Set R0 = 0 so we do not return an error

 LDMFD   R13!, {PC}^                \ Return from the subroutine

.star1

 ADR     R0, eliteTxStartError1     \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set [in bit 28 of the program counter]

.star2

 ADR     R0, eliteTxStartError2     \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set [in bit 28 of the program counter]

.star3

 ADR     R0, eliteTxStartError3     \ Set R0 to point to the error message

 LDMFD   R13!, {R14}                \ Return from the subroutine with the V flag
 ORRS    PC, R14, #1<<28            \ set [in bit 28 of the program counter]

.eliteTxStartError1

 EQUD    255
 EQUS    "Transmissions are already enabled"
 EQUB    0
 OPT     FN_AlignWithZeroes

.eliteTxStartError2

 EQUD    255
 EQUS    "Both the port and station number must be "
 EQUS    "non-zero to enable transmissions"
 EQUB    0
 OPT     FN_AlignWithZeroes

.eliteTxStartError3

 EQUD    255
 EQUS    "There was an error starting the transmission event"
 EQUB    0
 OPT     FN_AlignWithZeroes

.eliteTxStartHelp

 EQUS    "*EliteTxStart enables score transmissions."
 EQUB    13
 EQUS    "Syntax: *EliteTxStart"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; EliteTxReset
\       Type; Subroutine
\   Category; Econet
\    Summary; Implement the EliteTxReset command
\
\ ------------------------------------------------------------------------------
\
\ Other entry points;
\
\   EliteTxReset_SWI                Entry point from the Elite_SetStatus SWI
\
\ ******************************************************************************

.EliteTxReset

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

.EliteTxReset_SWI

 MOV     R0, #0                     \ Zero the kill tally and death count
 STR     R0, [R12, #netTally]
 STR     R0, [R12, #netDeaths]

 LDMFD   R13!, {PC}^                \ Return from the subroutine

.eliteTxResetHelp

 EQUS    "*EliteTxReset resets the kill tally and death count."
 EQUB    13
 EQUS    "Syntax: *EliteTxReset"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; EliteStatus
\       Type; Subroutine
\   Category; Econet
\    Summary; Implement the EliteStatus command
\
\ ******************************************************************************

.EliteStatus

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusIntro            \ Print the intro paragraph
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 SWI     XOS_Newline                \ Print a newline

 LDR     R0, [R12, #scoreEnabled]   \ Print the disabled or enabled message
 TEQ     R0, #0                     \ depending on the value of scoreEnabled
 ADREQ   R0, statusDisabled
 ADRNE   R0, statusEnabled
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusInterval1        \ Print 'Transmit interval;  '
 SWI     XOS_Write0

 LDR     R0, [R12, #scoreInterval]  \ Print the score interval as a positive
 ADD     R1, R12, #stringBuffer     \ integer [32-bit]
 MOV     R2, #12
 SWI     XOS_ConvertCardinal4
 SWI     XOS_Write0

 ADR     R0, statusInterval2        \ Print ' seconds'
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusStation          \ Print 'Scoreboard station; '
 SWI     XOS_Write0

 LDR     R0, [R12, #scoreNetwork]   \ Print the network number as a positive
 ADD     R1, R12, #stringBuffer     \ integer [8-bit]
 MOV     R2, #12
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 MOV     R0, #&2E                   \ Print a full stop
 SWI     XOS_WriteC

 LDR     R0, [R12, #scoreStation]   \ Set R0 to the station number

 CMP     R0, #100                   \ Pad out the station number with leading
 SWILT   XOS_WriteI+&30             \ zeroes so it's three digits
 CMP     R0, #10
 SWILT   XOS_WriteI+&30

 ADD     R1, R12, #stringBuffer     \ Print the station number as a positive
 MOV     R2, #12                    \ integer [8-bit]
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusPort             \ Print 'Scoreboard port;    '
 SWI     XOS_Write0

 LDR     R0, [R12, #scorePort]      \ Print the port number as a positive
 ADD     R1, R12, #stringBuffer     \ integer [8-bit]
 MOV     R2, #12
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 ADR     R0, statusKills            \ Print 'Kills/deaths;       '
 SWI     XOS_Write0

 LDR     R0, [R12, #netTally]       \ Print the kill tally as a positive
 ADD     R1, R12, #stringBuffer     \ integer [16-bit]
 MOV     R2, #12
 SWI     XOS_ConvertCardinal2
 SWI     XOS_Write0

 MOV     R0, #&2F                   \ Print a /
 SWI     XOS_WriteC

 LDR     R0, [R12, #netDeaths]      \ Print the death count as a positive
 ADD     R1, R12, #stringBuffer     \ integer [8-bit]
 MOV     R2, #12
 SWI     XOS_ConvertCardinal1
 SWI     XOS_Write0

 SWI     XOS_Newline                \ Print a newline

 SWI     XOS_Newline                \ Print a newline

 LDMFD   R13!, {PC}                 \ Return from the subroutine

.statusIntro

 EQUS    "Current status of Elite over Econet:"
 EQUB    0
 OPT     FN_AlignWithZeroes

.statusEnabled

 EQUS    "Transmissions:      Enabled"
 EQUB    0
 OPT     FN_AlignWithZeroes

.statusDisabled

 EQUS    "Transmissions:      Disabled"
 EQUB    0
 OPT     FN_AlignWithZeroes

.statusInterval1

 EQUS    "Transmit interval:  "
 EQUB    0
 OPT     FN_AlignWithZeroes

.statusInterval2

 EQUS    " seconds"
 EQUB    0
 OPT     FN_AlignWithZeroes

.statusStation

 EQUS    "Scoreboard station: "
 EQUB    0
 OPT     FN_AlignWithZeroes

.statusPort

 EQUS    "Scoreboard port:    "
 EQUB    0
 OPT     FN_AlignWithZeroes

.statusKills

 EQUS    "Kills/deaths:       "
 EQUB    0
 OPT     FN_AlignWithZeroes

.eliteStatusHelp

 EQUS    "*EliteStatus shows the current status of Elite over Econet."
 EQUB    13
 EQUS    "Syntax: *EliteStatus"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; SWIHandler
\       Type; Subroutine
\   Category; Econet
\    Summary; Handle SWI calls to the module
\
\ ******************************************************************************

.SWIHandler

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 CMP     R11, #4 * 4                \ Jump to the correct SWI, if R11 is in
 ADDLO   PC, PC, R11, LSL #2        \ the correct range [i.e. the number of
                                    \ SWIs in the jump table * 4]

 B       UnknownSWIError            \ R11 is out of range, so return an error

.jump

 B       SWI_Elite_GameOver         \ Jump to SWI 0 within this chunk

 B       SWI_Elite_GameRestart      \ Jump to SWI 1 within this chunk

 B       SWI_Elite_GetStatus        \ Jump to SWI 2 within this chunk

 B       SWI_Elite_SetStatus        \ Jump to SWI 3 within this chunk

\ ******************************************************************************
\
\       Name; UnknownSWIError
\       Type; Subroutine
\   Category; Econet
\    Summary; Return the unknown SWI error
\
\ ******************************************************************************

.UnknownSWIError

 ADR     R0, swiError               \ Transform the error message token in
 MOV     R1, #0                     \ swiError
 MOV     R2, #0
 FN_ADRL(4, title)
 SWI     XMessageTrans_ErrorLookup

 ORRS    PC, R14, #1<<28            \ Return from the subroutine with the V flag
                                    \ set [in bit 28 of the program counter]

\ ******************************************************************************
\
\       Name; swiError
\       Type; Variable
\   Category; Econet
\    Summary; Error block for the unknown SWI error
\
\ ******************************************************************************

.swiError

 EQUD    &1E6
 EQUS    "BadSWI"
 EQUB    0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; swiDecodingTable
\       Type; Variable
\   Category; Econet
\    Summary; Decoding table for the Elite_GameOver and Elite_GameRestart SWIs
\
\ ******************************************************************************

.swiDecodingTable

 EQUS    "Elite"                    \ Group prefix
 EQUB    0

 EQUS    "GameOver"                 \ SWI Elite_GameOver [&C0CC0]
 EQUB    0

 EQUS    "GameRestart"              \ SWI Elite_GameRestart [&C0CC1]
 EQUB    0

 EQUS    "GetStatus"                \ SWI Elite_GetStatus [&C0CC2]
 EQUB    0

 EQUS    "SetStatus"                \ SWI Elite_SetStatus [&C0CC3]
 EQUB    0

 EQUB    0                          \ End of table
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\       Name; SWI_Elite_GameOver
\       Type; Subroutine
\   Category; Econet
\    Summary; Code for the Elite_GameOver SWI
\
\ ******************************************************************************

.SWI_Elite_GameOver

 MOV     R0, #1                     \ Set the gameIsOver flag to 1 to denote
 STR     R0, [R12, #gameIsOver]     \ that the game is in the process of ending

 MOV     R0, #&29                   \ Run the original code that we replaced

 MOVS    PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name; SWI_Elite_GameRestart
\       Type; Subroutine
\   Category; Econet
\    Summary; Code for the Elite_GameRestart SWI
\
\ ******************************************************************************

.SWI_Elite_GameRestart

 LDR     R2, [R12, #gameIsOver]     \ If gameIsOver is zero then the game is not
 TEQ     R2, #0                     \ in the process of ending, which means we
 BEQ     notDeath                   \ are not printing the copyright message on
                                    \ the title screen following a death, so
                                    \ jump to notDeath to return from the
                                    \ subroutine

 LDR     R2, [R12, #netDeaths]      \ Otherwise this is the title screen
 ADD     R2, R2, #1                 \ following a death, so increment the death
 CMP     R2, #256                   \ count, keeping the result within one byte
 STRLT   R2, [R12, #netDeaths]

 MOV     R2, #0                     \ Zero the gameIsOver flag to denote that
 STR     R2, [R12, #gameIsOver]     \ the game is no longer in the process of
                                    \ ending

.notDeath

 MOV     R2, #&12C                  \ Run the original code that we replaced

 MOVS    PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name; SWI_Elite_GetStatus
\       Type; Subroutine
\   Category; Econet
\    Summary; Code for the Elite_GetStatus SWI
\
\ ******************************************************************************

.SWI_Elite_GetStatus

 LDR     R0, [R12, #scorePort]      \ Set R0 to R6 to the values we want to
 LDR     R1, [R12, #scoreStation]   \ return from the SWI
 LDR     R2, [R12, #scoreNetwork]
 LDR     R3, [R12, #netTally]
 LDR     R4, [R12, #netDeaths]
 LDR     R5, [R12, #scoreEnabled]
 LDR     R6, [R12, #scoreInterval]

 MOVS    PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name; SWI_Elite_SetStatus
\       Type; Subroutine
\   Category; Econet
\    Summary; Code for the Elite_SetStatus SWI
\
\ ------------------------------------------------------------------------------
\
\ Implement the following SWIs;
\
\   SYS 'Elite_SetStatus', 1, '<net.station>'       Set station number
\   SYS 'Elite_SetStatus', 2, <port>                Set port number
\   SYS 'Elite_SetStatus', 3                        Reset scores
\   SYS 'Elite_SetStatus', 4                        Start transmissions
\   SYS 'Elite_SetStatus', 5                        Stop transmissions
\   SYS 'Elite_SetStatus', 6, <interval>            Set interval
\   
\ ******************************************************************************

.SWI_Elite_SetStatus

 STMFD   R13!, {R14}                \ Store the return address on the stack

 TEQ     R0, #1                     \ Test R0 to match this SYS command;
                                    \ SYS 'Elite_SetStatus', 1, '<net.station>'

 MOVEQ   R0, R1                     \ Move the argument into R0 and jump to the
 BEQ     EliteTxStation_SWI         \ entry point in EliteTxStation to set the
                                    \ station number and return from the
                                    \ subroutine using a tail call

 TEQ     R0, #2                     \ Test R0 to match this SYS command;
                                    \ SYS 'Elite_SetStatus', 2, <port>

 MOVEQ   R2, R1                     \ Move the argument into R2 and jump to the
 BEQ     EliteTxPort_SWI            \ entry point in EliteTxPort to set the port
                                    \ number and return from the subroutine
                                    \ using a tail call

 TEQ     R0, #3                     \ Test R0 to match this SYS command;
                                    \ SYS 'Elite_SetStatus', 3

 BEQ     EliteTxReset_SWI           \ Jump to the entry point in EliteTxReset to
                                    \ reset the scores and return from the
                                    \ subroutine using a tail call

 TEQ     R0, #4                     \ Test R0 to match this SYS command;
                                    \ SYS 'Elite_SetStatus', 4

 BEQ     EliteTxStart_SWI           \ Jump to the entry point in EliteTxStart
                                    \ to start transmissions and return from
                                    \ the subroutine using a tail call

 TEQ     R0, #5                     \ Test R0 to match this SYS command;
                                    \ SYS 'Elite_SetStatus', 5

 BEQ     EliteTxStop_SWI            \ Jump to the entry point in EliteTxStop
                                    \ to stop transmissions and return from
                                    \ the subroutine using a tail call

 TEQ     R0, #6                     \ Check R0 to match this SYS command;
                                    \ SYS 'Elite_SetStatus', 6, <interval>

 MOVEQ   R2, R1                     \ Move the argument into R2 and jump to the
 BEQ     EliteTxInterval_SWI        \ entry point in EliteTxInterval to set the
                                    \ interval and return from the subroutine
                                    \ using a tail call

 LDMFD   R13!, {PC}^                \ Return from the subroutine

\ ******************************************************************************
\
\       Name; InitialiseModule
\       Type; Subroutine
\   Category; Econet
\    Summary; Initialise the module
\
\ ******************************************************************************

.InitialiseModule

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R2, [R12]                  \ Set R2 to the module's private word

 TEQ     R2, #0                     \ If the private word is non-zero then we
 MOVNE   R12, R2                    \ have already set up the module's private
 BNE     init1                      \ workspace and the private word contains
                                    \ the address of that workspace, so put the
                                    \ address of the workspace in R12 and jump
                                    \ to init1 to the initialisation of the
                                    \ module's workspace

                                    \ If we get here then the module's workspace
                                    \ has not been set up, so we do that now

 MOV     R0, #6                     \ Claim the correct number of bytes for the
 MOV     R3, #workspaceSize         \ workspace, returning the address of the
 SWI     XOS_Module                 \ workspace in R2

 LDMVSFD R13!, {PC}                 \ If the V flag is set then the claim has
                                    \ failed and the module can't be run, so
                                    \ return without initialising the module

 STR     R2, [R12]                  \ Otherwise the claim was successful, so set
                                    \ the module's private word to the address
                                    \ of the claimed memory

 MOV     R12, R2                    \ Set R12 to the address of the claimed
                                    \ memory

 MOV     R1, #0                     \ Reset the handle of the previous packet as
 STR     R1, [R12, #econetHandle]   \ there isn't one

 STR     R1, [R12, #taskHandle]      \ Zero the task handle for the Elite task

 STR     R1, [R12, #netTally]       \ Zero the kill tally

 STR     R1, [R12, #netDeaths]      \ Zero the death count

 STR     R1, [R12, #gameIsOver]     \ Zero the gameIsOver flag to denote that
                                    \ the game is not in the process of ending

 STR     R1, [R12, #patchApplied]   \ Zero the patchApplied flag to denote that
                                    \ the game over patch has not yet been
                                    \ applied

 STR     R1, [R12, #semaphore]      \ Zero the semaphore to indicate we are not
                                    \ currently running the event

 STR     R1, [R12, #scoreNetwork]   \ Zero the scoreboard network details
 STR     R1, [R12, #scoreStation]
 STR     R1, [R12, #scorePort]

 STR     R1, [R12, #scoreEnabled]   \ Disable transmissions by default

 MVN     R1, #0                     \ Set the current rank to -1, to indicate
 STR     R1, [R12, #currentRank]    \ that we haven't yet fetched it from the
                                    \ game

 MOV     R1, #10                    \ Initialise the transmission interval to
 STR     R1, [R12, #scoreInterval]  \ 10 seconds]

.init1

 MOV     R0, #50                    \ Add a call to the MonitorRank routine
 ADR     R1, MonitorRank            \ into the ticker event list so it gets
 MOV     R2, R12                    \ called twice each second [i.e. every 50
 SWI     XOS_CallEvery              \ centiseconds], to check the commander's
                                    \ rank for changes
                                    \
                                    \ Note that R2 contains the address of the
                                    \ module's private workspace, so this will
                                    \ be sent to the routine in R12 whenever it
                                    \ is called

 LDMVSFD R13!, {PC}                 \ If the V flag is set then the ticker has
                                    \ not been added and the module can't be
                                    \ run, so return without initialising the
                                    \ module

                                    \ If transmissions have already been started
                                    \ [presumably because this module is being
                                    \ reinitialised] then we need restart the
                                    \ ticker event

 LDR     R1, [R12, #scoreEnabled]   \ Set R1 to the current enabled state

 TEQ     R1, #1                     \ If transmissions have not been started, 
 BNE     init2                      \ jump to init2 to return from the
                                    \ subroutine

 LDR     R1, [R12, #scorePort]      \ Set R1 to the port number and R2 to the
 TEQ     R1, #0                     \ station number, setting the Z flag if
 LDRNE   R2, [R12, #scoreStation]   \ either of them is zero
 TEQNE   R2, #0

 BEQ     init2                      \ If either of them is zero, jump to init2
                                    \ to return from the subroutine

 LDR     R0, [R12, #scoreInterval]  \ Add a call to the TransmitData routine
 MOV     R1, #100                   \ into the ticker event list so it gets
 MUL     R0, R1, R0                 \ called every scoreInterval seconds, to
 FN_ADRL(1, TransmitData)           \ transmit the commander data to the
 MOV     R2, R12                    \ scoreboard
 SWI     XOS_CallEvery

.init2

 LDMFD   R13!, {PC}^                \ Return from the subroutine

\ ******************************************************************************
\
\       Name; FinaliseModule
\       Type; Subroutine
\   Category; Econet
\    Summary; Finalise the module
\
\ ******************************************************************************

.FinaliseModule

 STMFD   R13!, {R14}                \ Store the return address on the stack

 LDR     R12, [R12]                 \ Set R12 to the address of the module's
                                    \ private workspace

 ADR     R0, TransmitData           \ Remove the TransmitData routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called [we set R1 to the address of the
                                    \ module's private workspace so it matches
                                    \ the value of R2 that was used when adding
                                    \ the routine to the ticker list]

 ADR     R0, MonitorRank            \ Remove the MonitorRank routine from the
 MOV     R1, R12                    \ ticker event list so it is no longer
 SWI     XOS_RemoveTickerEvent      \ called

 LDR     R0, [R12, #econetHandle]   \ Fetch the handle of the previous packet

 TEQ     R0, #0                     \ If there is a handle, abandon the previous
 SWINE   XEconet_AbandonTransmit    \ transmission to recover its memory from
                                    \ the RMA

 MOV     R1, #0                     \ Reset the handle of the previous packet
 STR     R1, [R12, #econetHandle]

 LDMFD   R13!, {PC}^                \ Return from the subroutine

\ ******************************************************************************
\
\       Name; TransmitData
\       Type; Subroutine
\   Category; Econet
\    Summary; Create and send an Econet data packet
\
\ ******************************************************************************

.TransmitData

 STMFD   R13!, {R0-R12}             \ Store the registers that we want to use on
                                    \ the stack so they can be preserved

                                    \ As we are calling this routine via the
                                    \ ticker event list the system will call the
                                    \ routine in SVC mode with interrupts
                                    \ disabled, so for us to be able to call
                                    \ SWIs, we need to save R14_svc on the stack
                                    \ to prevent corruption of the return
                                    \ address
                                    \
                                    \ Just to be on the safe side, we won't
                                    \ assume the processor mode that we are in,
                                    \ we'll just save that too so we can revert
                                    \ when we're done

 MOV     R5, PC                     \ Extract the current processor mode into R5
 BIC     R4, R5, #3                 \ from bits 0 and 1 of the program counter

 TEQP    R4, #3                     \ Switch to SVC mode
 MOV     R0, R0

 STMFD   R13!, {R5, R14}            \ Store the original processor mode [in R5]
                                    \ and R14_svc on the stack, so we can revert
                                    \ both of them when we are done

 LDR     R2, [R12, #taskHandle]     \ If taskHandle is zero then we have not yet
 TEQ     R2, #0                     \ fetched the Elite task handle, so call
 BLEQ    FetchEliteTaskHandle       \ FetchEliteTaskHandle to fetch it, storing
                                    \ the result in both taskHandle and R2

 BEQ     skipT                      \ If the handle is still zero, then we can't
                                    \ find the Elite task, so jump to skipT to
                                    \ return from the subroutine

 MOV     R0, #5                     \ Call Wimp_ReadSysInfo to read information
 SWI     XWimp_ReadSysInfo          \ item 5 into R0, which is the handle of the
 BVS     skipT                      \ currently active task

 CMP     R0, R2                     \ If the handle of the currently active task
 BNE     skipT                      \ does not match the handle in R2, then
                                    \ Elite is not currently active, so jump to
                                    \ skipT to return from the subroutine as
                                    \ Elite is not paged in

\ADR     R0, string1Addr            \ Check to see if the first string to match
\LDR     R0, [R0]                   \ is in logical RAM
\MOV     R1, R0
\SWI     XOS_ValidateAddress
\BVS     skipT
\BCS     skipT
\
\LDR     R0, [R0]                   \ If the first string doesn't match, jump
\ADR     R1, string1Match           \ to skipT to return from the subroutine as
\LDR     R1, [R1]                   \ Elite is not paged in
\CMP     R0, R1
\BNE     skipT
\
\ADR     R0, string2Addr            \ Check to see if the second string to match
\LDR     R0, [R0]                   \ is in logical RAM
\MOV     R1, R0
\SWI     XOS_ValidateAddress
\BVS     skipT
\BCS     skipT
\
\LDR     R0, [R0]                   \ If the second string doesn't match, jump
\ADR     R1, string2Match           \ to skipT to return from the subroutine as
\LDR     R1, [R1]                   \ Elite is not paged in
\CMP     R0, R1
\BNE     skipT
\
\ADR     R0, string3Addr            \ Check to see if the third string to match
\LDR     R0, [R0]                   \ is in logical RAM
\MOV     R1, R0
\SWI     XOS_ValidateAddress
\BVS     skipT
\BCS     skipT
\
\LDR     R0, [R0]                   \ If the third string doesn't match, jump
\ADR     R1, string3Match           \ to skipT to return from the subroutine as
\LDR     R1, [R1]                   \ Elite is not paged in
\CMP     R0, R1
\BNE     skipT

                                    \ If we get here then Elite is paged in

 LDR     R0, [R12, #semaphore]      \ If the semaphore flag is non-zero then we
 TEQ     R0, #0                     \ are already running this routine from a
 BNE     doneT                      \ previous ticker event, so jump to doneT
                                    \ to return from the subroutine without
                                    \ resetting the semaphore

 MOV     R0, #1                     \ Set the semaphore flag to a non-zero value
 STR     R0, [R12, #semaphore]      \ to indicate that there is a transmission
                                    \ in progress

 LDR     R0, [R12, #econetHandle]   \ Fetch the handle of the previous packet

 TEQ     R0, #0                     \ If there is a handle, abandon the previous
 SWINE   XEconet_AbandonTransmit    \ transmission to recover its memory from
                                    \ the RMA

 ADR     R0, cmdrName               \ Check to see if the commander name is in
 LDR     R0, [R0]                   \ logical RAM
 ADD     R1, R0, #4
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R2, [R0]                   \ Fetch the first word of the commander
 TST     R2, #&000000FF             \ name, convert any null bytes to carriage
 ORREQ   R2, R2, #&0000000D         \ returns and store the result in trName
 TST     R2, #&0000FF00
 ORREQ   R2, R2, #&00000D00
 TST     R2, #&00FF0000
 ORREQ   R2, R2, #&000D0000
 TST     R2, #&FF000000
 ORREQ   R2, R2, #&0D000000
 STR     R2, [R12, #trName]

 LDR     R2, [R0, #4]               \ Fetch the second word of the commander
 TST     R2, #&000000FF             \ name, convert any null bytes to carriage
 ORREQ   R2, R2, #&0000000D         \ returns and store the result in trName,
 TST     R2, #&0000FF00             \ making sure the last character is always
 ORREQ   R2, R2, #&00000D00         \ a carriage return
 TST     R2, #&00FF0000
 ORREQ   R2, R2, #&000D0000
 BIC     R2, R2, #&FF000000
 ORR     R2, R2, #&0D000000
 STR     R2, [R12, #trName+4]

 MOV     R3, #1                     \ Set R3 to 1 [for Offender]

 ADR     R0, cmdrLegal              \ Check to see if the commander's legal
 LDR     R0, [R0]                   \ status is in logical RAM
 MOV     R1, R0
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R2, [R0]                   \ Set R2 to the commander's legal status

 CMP     R2, #&28                   \ If R2 <= &28 then set R3 to 0 [for Clean]
 MOVLE   R3, #0

 CMP     R2, #&3E8                  \ If R2 > &3E8 then set R3 to 3 [for
 MOVGT   R3, #3                     \ Fugitive]

 STRB    R3, [R12, #trLegal]        \ Set byte #8 to the legal status

 ADR     R0, cmdrCondition          \ Check to see if the commander's condition
 LDR     R0, [R0]                   \ is in logical RAM
 MOV     R1, R0
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R2, [R0]                   \ Set R2 to the commander's condition plus 1
 ADD     R2, R2, #1                 \ to give 1 = Green, 2 = Yellow, 3 = Red,
                                    \ 4 = Hyperspace, 5 = Witchspace, 6 = Docked

 CMP     R2, #4                     \ If condition is Hyperspace or Witchspace,
 CMPNE   R2, #5                     \ set R2 = 3 [for Red]
 MOVEQ   R2, #3

 CMP     R2, #6                     \ If condition is Docked, set R2 = 0
 MOVGE   R2, #0

 STRB    R2, [R12, #trCondition]    \ Set byte #9 to the condition

 MOV     R2, #4                     \ Set byte #16 to machine type 4 and zero
 STR     R2, [R12, #trMachine]      \ bytes #17 and #18 [so the forwarding
                                    \ station bytes are clear]

 LDR     R2, [R12, #netTally]       \ Set bytes #10 and #19 to the kill tally
 MOV     R0, R2, LSR #8
 STRB    R2, [R12, #trKillLo]
 STRB    R0, [R12, #trKillHi]

 LDRB    R2, [R12, #netDeaths]      \ Set byte #10 to the death count
 STRB    R2, [R12, #trDeaths]

 ADR     R0, cmdrCredits            \ Check to see if the commander credits are
 LDR     R0, [R0]                   \ in logical RAM
 MOV     R1, R0
 SWI     XOS_ValidateAddress
 BVS     skipT
 BCS     skipT

 LDR     R2, [R0]                   \ Set bytes #12-15 to the commander credits
 STR     R2, [R12, #trCredits]

                                    \ We now check to see if the transmission
                                    \ is correctly configured

 LDR     R1, [R12, #scorePort]      \ Set R1 to the port number and R2 to the
 TEQ     R1, #0                     \ station number, setting the Z flag if
 LDRNE   R2, [R12, #scoreStation]   \ either of them is zero
 TEQNE   R2, #0

 BEQ     skipT                      \ If either of them is zero, jump to skipT
                                    \ to skip the transmission

                                    \ We now do the data transmission

 MOV     R0, #0                     \ Set R0 to the flag byte

                                    \ R1 is already set to the port number

                                    \ R2 is already set to the station number

 LDR     R3, [R12, #scoreNetwork]   \ Set R3 to the network number

 ADD     R4, R12, #transmitBuffer   \ Set R4 to the buffer address

 MOV     R5, #20                    \ Set R5 to the buffer size

 MOV     R6, #1                     \ Set R6 to send this once

 MOV     R7, #0                     \ Set R7 to no delay

 SWI     XEconet_StartTransmit      \ Transmit the packet

 MOVVS   R0, #0                     \ If the call was not successful, zero the
                                    \ handle in R0

 STR     R0, [R12, #econetHandle]   \ Store the handle for this transmission

.skipT

 MOV     R0, #0                     \ Set the semaphore flag to zero to indicate
 STR     R0, [R12, #semaphore]      \ that we have finished this transmission

.doneT

 LDMFD   R13!, {R5, R14}            \ Restore R14_svc and R5 from the stack, so
                                    \ the latter contains the original processor
                                    \ mode from when we called this routine

 TEQP    R5, #0                     \ Set the processor mode to the original
 MOV     R0, R0                     \ mode in R5

 LDMFD   R13!, {R0-R12}             \ Retrieve the registers that we stored on
                                    \ the stack

 MOV     PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name; MonitorRank
\       Type; Subroutine
\   Category; Econet
\    Summary; Check the commander's rank and increase the net tally if it has
\             increased since last time
\
\ ******************************************************************************

.MonitorRank

 STMFD   R13!, {R0-R12}             \ Store the registers that we want to use on
                                    \ the stack so they can be preserved

                                    \ As we are calling this routine via the
                                    \ ticker event list the system will call the
                                    \ routine in SVC mode with interrupts
                                    \ disabled, so for us to be able to call
                                    \ SWIs, we need to save R14_svc on the stack
                                    \ to prevent corruption of the return
                                    \ address
                                    \
                                    \ Just to be on the safe side, we won't
                                    \ assume the processor mode that we are in,
                                    \ we'll just save that too so we can revert
                                    \ when we're done

 MOV     R5, PC                     \ Extract the current processor mode into R5
 BIC     R4, R5, #3                 \ from bits 0 and 1 of the program counter

 TEQP    R4, #3                     \ Switch to SVC mode
 MOV     R0, R0

 STMFD   R13!, {R5, R14}            \ Store the original processor mode [in R5]
                                    \ and R14_svc on the stack, so we can revert
                                    \ both of them when we are done

 LDR     R2, [R12, #taskHandle]     \ If taskHandle is zero then we have not yet
 TEQ     R2, #0                     \ fetched the Elite task handle, so call
 BLEQ    FetchEliteTaskHandle       \ FetchEliteTaskHandle to fetch it, storing
                                    \ the result in both taskHandle and R2

 BEQ     skipM                      \ If the handle is still zero, then we can't
                                    \ find the Elite task, so jump to skipM to
                                    \ return from the subroutine

 MOV     R0, #5                     \ Call Wimp_ReadSysInfo to read information
 SWI     XWimp_ReadSysInfo          \ item 5 into R0, which is the handle of the
 BVS     skipM                      \ currently active task

 CMP     R0, R2                     \ If the handle of the currently active task
 BNE     skipM                      \ does not match the handle in R2, then
                                    \ Elite is not currently active, so jump to
                                    \ skipM to return from the subroutine as
                                    \ Elite is not paged in

\ADR     R0, string1Addr            \ Check to see if the first string to match
\LDR     R0, [R0]                   \ is in logical RAM
\MOV     R1, R0
\SWI     XOS_ValidateAddress
\BVS     skipM
\BCS     skipM
\
\LDR     R0, [R0]                   \ If the first string doesn't match, jump
\ADR     R1, string1Match           \ to skipM to return from the subroutine as
\LDR     R1, [R1]                   \ Elite is not paged in
\CMP     R0, R1
\BNE     skipM
\
\ADR     R0, string2Addr            \ Check to see if the second string to match
\LDR     R0, [R0]                   \ is in logical RAM
\MOV     R1, R0
\SWI     XOS_ValidateAddress
\BVS     skipM
\BCS     skipM
\
\LDR     R0, [R0]                   \ If the second string doesn't match, jump
\ADR     R1, string2Match           \ to skipM to return from the subroutine as
\LDR     R1, [R1]                   \ Elite is not paged in
\CMP     R0, R1
\BNE     skipM
\
\ADR     R0, string3Addr            \ Check to see if the third string to match
\LDR     R0, [R0]                   \ is in logical RAM
\MOV     R1, R0
\SWI     XOS_ValidateAddress
\BVS     skipM
\BCS     skipM
\
\LDR     R0, [R0]                   \ If the third string doesn't match, jump
\ADR     R1, string3Match           \ to skipM to return from the subroutine as
\LDR     R1, [R1]                   \ Elite is not paged in
\CMP     R0, R1
\BNE     skipM

                                    \ If we get here then Elite is paged in

 LDR     R1, [R12, #patchApplied]   \ Set R1 to the patchApplied flag

 TEQ     R1, #1                     \ If R1 = 1 then we have already applied the
 BEQ     skipP                      \ patch, so skip the following

 ADR     R0, gameOverAddr           \ Deploy the first GAME OVER patch if the
 LDR     R0, [R0]                   \ address is in logical RAM
 MOV     R1, R0
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM
 ADR     R1, gameOverPatch
 LDR     R1, [R1]
 STR     R1, [R0]

 ADR     R0, restartAddr            \ Deploy the second GAME OVER patch if the
 LDR     R0, [R0]                   \ address is in logical RAM
 MOV     R1, R0
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM
 ADR     R1, restartPatch
 LDR     R1, [R1]
 STR     R1, [R0]

 MOV     R1, #1                     \ Set the patchApplied flag to 1 to denote
 STR     R1, [R12, #patchApplied]   \ that the game over patch has been applied

.skipP

 ADR     R0, cmdrRank               \ Check to see if the commander's rank is in
 LDR     R0, [R0]                   \ logical RAM
 MOV     R1, R0
 SWI     XOS_ValidateAddress
 BVS     skipM
 BCS     skipM

 LDR     R1, [R12, #currentRank]    \ Set R1 to the last rank that we recorded

 LDR     R2, [R0]                   \ Set R2 to the commander's rank from the
 STR     R2, [R12, #currentRank]    \ game and store it in currentRank

 CMN     R1, #1                     \ If this is the first rank we have fetched
 BEQ     skipM                      \ then R1 will be -1, so jump to skipM to
                                    \ skip the comparison with last time

 CMP     R2, R1                     \ If the new rank in R2 is greater than the
 LDRGT   R3, [R12, #netTally]       \ previous rank in R1, increase the kill
 ADDGT   R3, R3, #1                 \ tally
 STRGT   R3, [R12, #netTally]

.skipM

 LDMFD   R13!, {R5, R14}            \ Restore R14_svc and R5 from the stack, so
                                    \ the latter contains the original processor
                                    \ mode from when we called this routine

 TEQP    R5, #0                     \ Set the processor mode to the original
 MOV     R0, R0                     \ mode in R5

 LDMFD   R13!, {R0-R12}             \ Retrieve the registers that we stored on
                                    \ the stack

 MOV     PC, R14                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name; FetchEliteTaskHandle
\       Type; Subroutine
\   Category; Econet
\    Summary; Fetch the task handle for Archimedes Elite
\
\ ------------------------------------------------------------------------------
\
\ Returns;
\
\   R0                              The result;
\
\                                     * 0 = Elite task not found
\
\                                     * Non-zero = The handle of the Elite task
\
\   Z flag                          Set according to the result
\
\ ******************************************************************************

.FetchEliteTaskHandle

 STMFD   R13!, {R14}                \ Store the return address on the stack

 MOV     R0, #0                     \ We work our way through all the tasks with
                                    \ TaskManager_EnumerateTasks, so set R0 to 0
                                    \ to keep track of the returned task

.hand1

 ADD     R1, R12, #taskBuffer       \ Fetch details of the next task into the
 MOV     R2, #16                    \ 16-byte buffer at taskBuffer
 SWI     XTaskManager_EnumerateTasks

 MOVVS   R0, #0                     \ IF the SWI call failed, jump to hand2 with
 BVS     hand2                      \ R0 set to 0 to indicate that the Elite
                                    \ task was not found

 CMP     R0, #0                     \ If R0 < 0 then we have run out of tasks to
 MOVLT   R0, #0                     \ check, so jump to hand2 with R0 set to 0
 BLT     hand2                      \ to indicate that the Elite task was not
                                    \ found

                                    \ If we get here then we have fetched the
                                    \ details of the next task into the buffer

 LDR     R3, [R12, #taskBuffer+4]   \ Set R3 to the first second word in the
                                    \ buffer, which contains the address of the
                                    \ task name

 ADR     R5, eliteTaskName          \ Set R5 to the string 'Elite', which is the
                                    \ task name we want to match

 LDR     R4, [R3], #4               \ If the first word of the fetched task name
 LDR     R6, [R5], #4               \ does not match 'Elit', jump to hand1 to
 CMP     R4, R6                     \ fetch the next task name
 BNE     hand1

 LDR     R4, [R3], #4               \ If the second word of the fetched task
 BIC     R4, R4, #&FF000000         \ name does not match 'e' and a null, jump
 BIC     R4, R4, #&00FF0000         \ to hand1 to fetch the next task name
 LDR     R6, [R5], #4
 CMP     R4, R6
 BNE     hand1

 LDR     R0, [R12, #taskBuffer]     \ If we get here then we have a match and we
 STR     R0, [R12, #taskHandle]     \ have found the Elite task, so copy the
                                    \ task handle from the first word of the
                                    \ buffer into taskHandle

.hand2

                                    \ At this point R0 is either zero [if we
                                    \ have not managed to find the Elite task]
                                    \ or it contains the non-zero task handle

 MOVS    R2, R0                     \ Set R2 to R0, setting the flags, so we
                                    \ return the handle in R2 or a zero for no
                                    \ match

 LDMFD   R13!, {PC}                 \ Return from the subroutine

\ ******************************************************************************
\
\       Name; Archimedes Elite addresses [version 1.14]
\       Type; Workspace
\   Category; Econet
\    Summary; Addresses for the commander data and version strings in Elite
\
\ ******************************************************************************

.cmdrName

 EQUD    &0005A698

.cmdrRank

 EQUD    &0005A960

.cmdrCredits

 EQUD    &0006534C

.cmdrLegal

 EQUD    &00065398

.cmdrCondition

 EQUD    &000653A0

\.string1Addr
\
\EQUD    &0001AF14
\
\.string1Match
\
\EQUD    &4E495247                  \ GRIN [part of 'CLIVE GRINGRAS']
\
\.string2Addr
\
\EQUD    &0001AF00
\
\.string2Match
\
\EQUD    &45525241                  \ ARRE [part of 'WARREN BURCH']
\
\.string3Addr
\
\EQUD    &00071508
\
\.string3Match
\
\EQUD    &34312E31                  \ 1.14 [part of 'Version 1.14']

.gameOverAddr

 EQUD    &0000BBD0

.gameOverPatch

 SWI     XElite_GameOver            \ Replaces MOV R0, #&29

.restartAddr

 EQUD    &0001AF24

.restartPatch

 SWI     XElite_GameRestart         \ Replaces MOV R2, #&12C

.eliteTaskName

 EQUS "Elite"
 EQUB 0
 OPT     FN_AlignWithZeroes

\ ******************************************************************************
\
\ Two-pass assembly loop
\
\ ******************************************************************************

]

 NEXT pass%                         : REM Loop back for the second pass

REM ******************************************************************************
REM
REM Save EliteNet
REM
REM ******************************************************************************

 OSCLI "SAVE EliteNet "+STR$~CODE%+" "+STR$~O%+" "+STR$~CODE+" "+STR$~CODE
 OSCLI "SetType EliteNet Module"

 END

 DEF FN_AlignWithZeroes
  a = P% AND 3
  IF a > 0 THEN
   FOR I% = 1 TO 4 - a
    [
     OPT pass%
     EQUB 0
    ]
   NEXT I%
  ENDIF
 =pass%

 DEF FN_ADRL(reg,loc)
  p%=P%
  IF loc>p% THEN
   [ OPT pass%
     ADD reg,PC,#(loc-p%-8)DIV&100<<8
     ADD reg,reg,#(loc-p%-8)MOD&100
   ]
  ELSE
   [ OPT pass%
     SUB reg,PC,#(p%+8-loc)DIV&100<<8
     SUB reg,reg,#(p%+8-loc)MOD&100
   ]
  ENDIF
 =""
